### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly


type Account {
  number: Int!
  routing: Int!
  type: AccountType!
}

input AccountCreateInput {
  number: Int!
  routing: Int!
  type: AccountType!
}

input AccountCreateManyInput {
  create: [AccountCreateInput!]
}

input AccountRestrictedWhereInput {
  AND: [AccountRestrictedWhereInput!]
  number: Int
  number_gt: Int
  number_gte: Int
  number_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_not: Int
  number_not_in: [Int!]
  routing: Int
  routing_gt: Int
  routing_gte: Int
  routing_in: [Int!]
  routing_lt: Int
  routing_lte: Int
  routing_not: Int
  routing_not_in: [Int!]
  type: AccountType
  type_in: [AccountType!]
  type_not: AccountType
  type_not_in: [AccountType!]
}

input AccountScalarWhereInput {
  AND: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
  number: Int
  number_gt: Int
  number_gte: Int
  number_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_not: Int
  number_not_in: [Int!]
  OR: [AccountScalarWhereInput!]
  routing: Int
  routing_gt: Int
  routing_gte: Int
  routing_in: [Int!]
  routing_lt: Int
  routing_lte: Int
  routing_not: Int
  routing_not_in: [Int!]
  type: AccountType
  type_in: [AccountType!]
  type_not: AccountType
  type_not_in: [AccountType!]
}

enum AccountType {
  CHECKING
  SAVINGS
}

input AccountUpdateManyDataInput {
  number: Int
  routing: Int
  type: AccountType
}

input AccountUpdateManyInput {
  create: [AccountCreateInput!]
  deleteMany: [AccountScalarWhereInput!]
  updateMany: [AccountUpdateManyWithWhereNestedInput!]
}

input AccountUpdateManyWithWhereNestedInput {
  data: AccountUpdateManyDataInput!
  where: AccountScalarWhereInput!
}

input AccountWhereInput {
  AND: [AccountWhereInput!]
  number: Int
  number_gt: Int
  number_gte: Int
  number_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_not: Int
  number_not_in: [Int!]
  routing: Int
  routing_gt: Int
  routing_gte: Int
  routing_in: [Int!]
  routing_lt: Int
  routing_lte: Int
  routing_not: Int
  routing_not_in: [Int!]
  type: AccountType
  type_in: [AccountType!]
  type_not: AccountType
  type_not_in: [AccountType!]
}

type Billing {
  accounts: [Account!]
  cards: [Card!]
}

input BillingCreateInput {
  accounts: AccountCreateManyInput
  cards: CardCreateManyInput
}

input BillingCreateOneInput {
  create: BillingCreateInput
}

input BillingUpdateDataInput {
  accounts: AccountUpdateManyInput
  cards: CardUpdateManyInput
}

input BillingUpdateOneInput {
  create: BillingCreateInput
  delete: Boolean
  disconnect: Boolean
  update: BillingUpdateDataInput
  upsert: BillingUpsertNestedInput
}

input BillingUpsertNestedInput {
  create: BillingCreateInput!
  update: BillingUpdateDataInput!
}

input BillingWhereInput {
  accounts_every: AccountRestrictedWhereInput
  accounts_none: AccountRestrictedWhereInput
  accounts_some: AccountWhereInput
  AND: [BillingWhereInput!]
  cards_every: CardRestrictedWhereInput
  cards_none: CardRestrictedWhereInput
  cards_some: CardWhereInput
}

type Card {
  cvv: Int!
  expiration: DateTime!
  name: String!
  number: Int!
  type: CardType!
}

input CardCreateInput {
  cvv: Int!
  expiration: DateTime!
  name: String!
  number: Int!
  type: CardType!
}

input CardCreateManyInput {
  create: [CardCreateInput!]
}

input CardRestrictedWhereInput {
  AND: [CardRestrictedWhereInput!]
  cvv: Int
  cvv_gt: Int
  cvv_gte: Int
  cvv_in: [Int!]
  cvv_lt: Int
  cvv_lte: Int
  cvv_not: Int
  cvv_not_in: [Int!]
  expiration: DateTime
  expiration_gt: DateTime
  expiration_gte: DateTime
  expiration_in: [DateTime!]
  expiration_lt: DateTime
  expiration_lte: DateTime
  expiration_not: DateTime
  expiration_not_in: [DateTime!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  number: Int
  number_gt: Int
  number_gte: Int
  number_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_not: Int
  number_not_in: [Int!]
  type: CardType
  type_in: [CardType!]
  type_not: CardType
  type_not_in: [CardType!]
}

input CardScalarWhereInput {
  AND: [CardScalarWhereInput!]
  cvv: Int
  cvv_gt: Int
  cvv_gte: Int
  cvv_in: [Int!]
  cvv_lt: Int
  cvv_lte: Int
  cvv_not: Int
  cvv_not_in: [Int!]
  expiration: DateTime
  expiration_gt: DateTime
  expiration_gte: DateTime
  expiration_in: [DateTime!]
  expiration_lt: DateTime
  expiration_lte: DateTime
  expiration_not: DateTime
  expiration_not_in: [DateTime!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [CardScalarWhereInput!]
  number: Int
  number_gt: Int
  number_gte: Int
  number_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_not: Int
  number_not_in: [Int!]
  OR: [CardScalarWhereInput!]
  type: CardType
  type_in: [CardType!]
  type_not: CardType
  type_not_in: [CardType!]
}

enum CardType {
  CREDIT
  DEBIT
}

input CardUpdateManyDataInput {
  cvv: Int
  expiration: DateTime
  name: String
  number: Int
  type: CardType
}

input CardUpdateManyInput {
  create: [CardCreateInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  data: CardUpdateManyDataInput!
  where: CardScalarWhereInput!
}

input CardWhereInput {
  AND: [CardWhereInput!]
  cvv: Int
  cvv_gt: Int
  cvv_gte: Int
  cvv_in: [Int!]
  cvv_lt: Int
  cvv_lte: Int
  cvv_not: Int
  cvv_not_in: [Int!]
  expiration: DateTime
  expiration_gt: DateTime
  expiration_gte: DateTime
  expiration_in: [DateTime!]
  expiration_lt: DateTime
  expiration_lte: DateTime
  expiration_not: DateTime
  expiration_not_in: [DateTime!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  number: Int
  number_gt: Int
  number_gte: Int
  number_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_not: Int
  number_not_in: [Int!]
  type: CardType
  type_in: [CardType!]
  type_not: CardType
  type_not_in: [CardType!]
}

type Career {
  company: String!
  experience: [Experience!]
  position: String!
}

input CareerCreateInput {
  company: String!
  experience: ExperienceCreateManyInput
  position: String!
}

input CareerCreateOneInput {
  create: CareerCreateInput
}

input CareerUpdateDataInput {
  company: String
  experience: ExperienceUpdateManyInput
  position: String
}

input CareerUpdateOneInput {
  create: CareerCreateInput
  delete: Boolean
  disconnect: Boolean
  update: CareerUpdateDataInput
  upsert: CareerUpsertNestedInput
}

input CareerUpsertNestedInput {
  create: CareerCreateInput!
  update: CareerUpdateDataInput!
}

input CareerWhereInput {
  AND: [CareerWhereInput!]
  company: String
  company_contains: String
  company_ends_with: String
  company_gt: String
  company_gte: String
  company_in: [String!]
  company_lt: String
  company_lte: String
  company_not: String
  company_not_contains: String
  company_not_ends_with: String
  company_not_in: [String!]
  company_not_starts_with: String
  company_starts_with: String
  experience_every: ExperienceRestrictedWhereInput
  experience_none: ExperienceRestrictedWhereInput
  experience_some: ExperienceWhereInput
  position: String
  position_contains: String
  position_ends_with: String
  position_gt: String
  position_gte: String
  position_in: [String!]
  position_lt: String
  position_lte: String
  position_not: String
  position_not_contains: String
  position_not_ends_with: String
  position_not_in: [String!]
  position_not_starts_with: String
  position_starts_with: String
}

type Comment {
  _createdAt: DateTime!
  _discussionId: ID!
  _id: ID!
  _parentId: Comment
  _updatedAt: DateTime!
  author: Person!
  content: String!
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentCreateInput {
  _discussionId: ID!
  _id: ID
  _parentId: CommentCreateOneInput
  author: PersonCreateOneInput!
  content: String!
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentCreateOneInput {
  connect: CommentWhereUniqueInput
  create: CommentCreateInput
}

enum CommentOrderByInput {
  _createdAt_ASC
  _createdAt_DESC
  _discussionId_ASC
  _discussionId_DESC
  _id_ASC
  _id_DESC
  _updatedAt_ASC
  _updatedAt_DESC
  content_ASC
  content_DESC
  fullSlug_ASC
  fullSlug_DESC
  slug_ASC
  slug_DESC
  type_ASC
  type_DESC
}

enum CommentType {
  CONVERSATION
  REVIEW
}

input CommentUpdateDataInput {
  _discussionId: ID
  _parentId: CommentUpdateOneInput
  author: PersonUpdateOneRequiredInput
  content: String
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentUpdateInput {
  _discussionId: ID
  _parentId: CommentUpdateOneInput
  author: PersonUpdateOneRequiredInput
  content: String
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentUpdateOneInput {
  connect: CommentWhereUniqueInput
  create: CommentCreateInput
  delete: Boolean
  disconnect: Boolean
  update: CommentUpdateDataInput
  upsert: CommentUpsertNestedInput
}

input CommentUpsertNestedInput {
  create: CommentCreateInput!
  update: CommentUpdateDataInput!
}

input CommentWhereInput {
  _createdAt: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_not: DateTime
  _createdAt_not_in: [DateTime!]
  _discussionId: ID
  _discussionId_contains: ID
  _discussionId_ends_with: ID
  _discussionId_gt: ID
  _discussionId_gte: ID
  _discussionId_in: [ID!]
  _discussionId_lt: ID
  _discussionId_lte: ID
  _discussionId_not: ID
  _discussionId_not_contains: ID
  _discussionId_not_ends_with: ID
  _discussionId_not_in: [ID!]
  _discussionId_not_starts_with: ID
  _discussionId_starts_with: ID
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  _parentId: CommentWhereInput
  _updatedAt: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_not: DateTime
  _updatedAt_not_in: [DateTime!]
  AND: [CommentWhereInput!]
  author: PersonWhereInput
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  fullSlug: String
  fullSlug_contains: String
  fullSlug_ends_with: String
  fullSlug_gt: String
  fullSlug_gte: String
  fullSlug_in: [String!]
  fullSlug_lt: String
  fullSlug_lte: String
  fullSlug_not: String
  fullSlug_not_contains: String
  fullSlug_not_ends_with: String
  fullSlug_not_in: [String!]
  fullSlug_not_starts_with: String
  fullSlug_starts_with: String
  slug: String
  slug_contains: String
  slug_ends_with: String
  slug_gt: String
  slug_gte: String
  slug_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_not: String
  slug_not_contains: String
  slug_not_ends_with: String
  slug_not_in: [String!]
  slug_not_starts_with: String
  slug_starts_with: String
  type: CommentType
  type_in: [CommentType!]
  type_not: CommentType
  type_not_in: [CommentType!]
}

input CommentWhereUniqueInput {
  _id: ID
  fullSlug: String
}

type Contact {
  address1: String!
  address2: String!
  city: String!
  country: String!
  emails: [String!]!
  phones: [String!]!
  postalCode: String!
  state: String!
}

input ContactCreateemailsInput {
  set: [String!]
}

input ContactCreateInput {
  address1: String!
  address2: String!
  city: String!
  country: String!
  emails: ContactCreateemailsInput
  phones: ContactCreatephonesInput
  postalCode: String!
  state: String!
}

input ContactCreateOneInput {
  create: ContactCreateInput
}

input ContactCreatephonesInput {
  set: [String!]
}

input ContactUpdateDataInput {
  address1: String
  address2: String
  city: String
  country: String
  emails: ContactUpdateemailsInput
  phones: ContactUpdatephonesInput
  postalCode: String
  state: String
}

input ContactUpdateemailsInput {
  set: [String!]
}

input ContactUpdateOneInput {
  create: ContactCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ContactUpdateDataInput
  upsert: ContactUpsertNestedInput
}

input ContactUpdatephonesInput {
  set: [String!]
}

input ContactUpsertNestedInput {
  create: ContactCreateInput!
  update: ContactUpdateDataInput!
}

input ContactWhereInput {
  address1: String
  address1_contains: String
  address1_ends_with: String
  address1_gt: String
  address1_gte: String
  address1_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_not: String
  address1_not_contains: String
  address1_not_ends_with: String
  address1_not_in: [String!]
  address1_not_starts_with: String
  address1_starts_with: String
  address2: String
  address2_contains: String
  address2_ends_with: String
  address2_gt: String
  address2_gte: String
  address2_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_not: String
  address2_not_contains: String
  address2_not_ends_with: String
  address2_not_in: [String!]
  address2_not_starts_with: String
  address2_starts_with: String
  AND: [ContactWhereInput!]
  city: String
  city_contains: String
  city_ends_with: String
  city_gt: String
  city_gte: String
  city_in: [String!]
  city_lt: String
  city_lte: String
  city_not: String
  city_not_contains: String
  city_not_ends_with: String
  city_not_in: [String!]
  city_not_starts_with: String
  city_starts_with: String
  country: String
  country_contains: String
  country_ends_with: String
  country_gt: String
  country_gte: String
  country_in: [String!]
  country_lt: String
  country_lte: String
  country_not: String
  country_not_contains: String
  country_not_ends_with: String
  country_not_in: [String!]
  country_not_starts_with: String
  country_starts_with: String
  postalCode: String
  postalCode_contains: String
  postalCode_ends_with: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_not: String
  postalCode_not_contains: String
  postalCode_not_ends_with: String
  postalCode_not_in: [String!]
  postalCode_not_starts_with: String
  postalCode_starts_with: String
  state: String
  state_contains: String
  state_ends_with: String
  state_gt: String
  state_gte: String
  state_in: [String!]
  state_lt: String
  state_lte: String
  state_not: String
  state_not_contains: String
  state_not_ends_with: String
  state_not_in: [String!]
  state_not_starts_with: String
  state_starts_with: String
}

scalar DateTime

enum DimensionScale {
  FOOT
  METER
}

type Document {
  _createdAt: DateTime!
  _id: ID!
  _publishedAt: DateTime
  _updatedAt: DateTime!
  author: Person!
  category: DocumentCategory!
  content: String!
  subtitle: String
  title: String!
  type: DocumentType!
}

enum DocumentCategory {
  CORPORATE
  UNCATEGORIZED
}

input DocumentCreateInput {
  _id: ID
  _publishedAt: DateTime
  author: PersonCreateOneInput!
  category: DocumentCategory
  content: String!
  subtitle: String
  title: String!
  type: DocumentType
}

enum DocumentOrderByInput {
  _createdAt_ASC
  _createdAt_DESC
  _id_ASC
  _id_DESC
  _publishedAt_ASC
  _publishedAt_DESC
  _updatedAt_ASC
  _updatedAt_DESC
  category_ASC
  category_DESC
  content_ASC
  content_DESC
  subtitle_ASC
  subtitle_DESC
  title_ASC
  title_DESC
  type_ASC
  type_DESC
}

enum DocumentType {
  DEFAULT
  INSIGHT
  POLICY
}

input DocumentUpdateInput {
  _publishedAt: DateTime
  author: PersonUpdateOneRequiredInput
  category: DocumentCategory
  content: String
  subtitle: String
  title: String
  type: DocumentType
}

input DocumentWhereInput {
  _createdAt: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_not: DateTime
  _createdAt_not_in: [DateTime!]
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  _publishedAt: DateTime
  _publishedAt_gt: DateTime
  _publishedAt_gte: DateTime
  _publishedAt_in: [DateTime!]
  _publishedAt_lt: DateTime
  _publishedAt_lte: DateTime
  _publishedAt_not: DateTime
  _publishedAt_not_in: [DateTime!]
  _updatedAt: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_not: DateTime
  _updatedAt_not_in: [DateTime!]
  AND: [DocumentWhereInput!]
  author: PersonWhereInput
  category: DocumentCategory
  category_in: [DocumentCategory!]
  category_not: DocumentCategory
  category_not_in: [DocumentCategory!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  subtitle: String
  subtitle_contains: String
  subtitle_ends_with: String
  subtitle_gt: String
  subtitle_gte: String
  subtitle_in: [String!]
  subtitle_lt: String
  subtitle_lte: String
  subtitle_not: String
  subtitle_not_contains: String
  subtitle_not_ends_with: String
  subtitle_not_in: [String!]
  subtitle_not_starts_with: String
  subtitle_starts_with: String
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  type: DocumentType
  type_in: [DocumentType!]
  type_not: DocumentType
  type_not_in: [DocumentType!]
}

input DocumentWhereUniqueInput {
  _id: ID
  title: String
}

type Experience {
  company: String!
  description: String
  end: DateTime!
  position: String!
  start: DateTime!
}

input ExperienceCreateInput {
  company: String!
  description: String
  end: DateTime!
  position: String!
  start: DateTime!
}

input ExperienceCreateManyInput {
  create: [ExperienceCreateInput!]
}

input ExperienceRestrictedWhereInput {
  AND: [ExperienceRestrictedWhereInput!]
  company: String
  company_contains: String
  company_ends_with: String
  company_gt: String
  company_gte: String
  company_in: [String!]
  company_lt: String
  company_lte: String
  company_not: String
  company_not_contains: String
  company_not_ends_with: String
  company_not_in: [String!]
  company_not_starts_with: String
  company_starts_with: String
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  end: DateTime
  end_gt: DateTime
  end_gte: DateTime
  end_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_not: DateTime
  end_not_in: [DateTime!]
  position: String
  position_contains: String
  position_ends_with: String
  position_gt: String
  position_gte: String
  position_in: [String!]
  position_lt: String
  position_lte: String
  position_not: String
  position_not_contains: String
  position_not_ends_with: String
  position_not_in: [String!]
  position_not_starts_with: String
  position_starts_with: String
  start: DateTime
  start_gt: DateTime
  start_gte: DateTime
  start_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_not: DateTime
  start_not_in: [DateTime!]
}

input ExperienceScalarWhereInput {
  AND: [ExperienceScalarWhereInput!]
  company: String
  company_contains: String
  company_ends_with: String
  company_gt: String
  company_gte: String
  company_in: [String!]
  company_lt: String
  company_lte: String
  company_not: String
  company_not_contains: String
  company_not_ends_with: String
  company_not_in: [String!]
  company_not_starts_with: String
  company_starts_with: String
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  end: DateTime
  end_gt: DateTime
  end_gte: DateTime
  end_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_not: DateTime
  end_not_in: [DateTime!]
  NOT: [ExperienceScalarWhereInput!]
  OR: [ExperienceScalarWhereInput!]
  position: String
  position_contains: String
  position_ends_with: String
  position_gt: String
  position_gte: String
  position_in: [String!]
  position_lt: String
  position_lte: String
  position_not: String
  position_not_contains: String
  position_not_ends_with: String
  position_not_in: [String!]
  position_not_starts_with: String
  position_starts_with: String
  start: DateTime
  start_gt: DateTime
  start_gte: DateTime
  start_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_not: DateTime
  start_not_in: [DateTime!]
}

input ExperienceUpdateManyDataInput {
  company: String
  description: String
  end: DateTime
  position: String
  start: DateTime
}

input ExperienceUpdateManyInput {
  create: [ExperienceCreateInput!]
  deleteMany: [ExperienceScalarWhereInput!]
  updateMany: [ExperienceUpdateManyWithWhereNestedInput!]
}

input ExperienceUpdateManyWithWhereNestedInput {
  data: ExperienceUpdateManyDataInput!
  where: ExperienceScalarWhereInput!
}

input ExperienceWhereInput {
  AND: [ExperienceWhereInput!]
  company: String
  company_contains: String
  company_ends_with: String
  company_gt: String
  company_gte: String
  company_in: [String!]
  company_lt: String
  company_lte: String
  company_not: String
  company_not_contains: String
  company_not_ends_with: String
  company_not_in: [String!]
  company_not_starts_with: String
  company_starts_with: String
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  end: DateTime
  end_gt: DateTime
  end_gte: DateTime
  end_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_not: DateTime
  end_not_in: [DateTime!]
  position: String
  position_contains: String
  position_ends_with: String
  position_gt: String
  position_gte: String
  position_in: [String!]
  position_lt: String
  position_lte: String
  position_not: String
  position_not_contains: String
  position_not_ends_with: String
  position_not_in: [String!]
  position_not_starts_with: String
  position_starts_with: String
  start: DateTime
  start_gt: DateTime
  start_gte: DateTime
  start_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_not: DateTime
  start_not_in: [DateTime!]
}

enum Gender {
  FEMALE
  MALE
  OTHER
}

scalar Json

type Manufacturer {
  model: String!
  releaseDate: DateTime!
}

input ManufacturerCreateInput {
  model: String!
  releaseDate: DateTime!
}

input ManufacturerCreateOneInput {
  create: ManufacturerCreateInput
}

input ManufacturerUpdateDataInput {
  model: String
  releaseDate: DateTime
}

input ManufacturerUpdateOneInput {
  create: ManufacturerCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ManufacturerUpdateDataInput
  upsert: ManufacturerUpsertNestedInput
}

input ManufacturerUpsertNestedInput {
  create: ManufacturerCreateInput!
  update: ManufacturerUpdateDataInput!
}

input ManufacturerWhereInput {
  AND: [ManufacturerWhereInput!]
  model: String
  model_contains: String
  model_ends_with: String
  model_gt: String
  model_gte: String
  model_in: [String!]
  model_lt: String
  model_lte: String
  model_not: String
  model_not_contains: String
  model_not_ends_with: String
  model_not_in: [String!]
  model_not_starts_with: String
  model_starts_with: String
  releaseDate: DateTime
  releaseDate_gt: DateTime
  releaseDate_gte: DateTime
  releaseDate_in: [DateTime!]
  releaseDate_lt: DateTime
  releaseDate_lte: DateTime
  releaseDate_not: DateTime
  releaseDate_not_in: [DateTime!]
}

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  createDocument(data: DocumentCreateInput!): Document!
  createNotification(data: NotificationCreateInput!): Notification!
  createOrder(data: OrderCreateInput!): Order!
  createPerson(data: PersonCreateInput!): Person!
  createProduct(data: ProductCreateInput!): Product!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteProduct(where: ProductWhereUniqueInput!): Product
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateNotification(data: NotificationUpdateInput!, where: NotificationWhereUniqueInput!): Notification
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
}

type Name {
  first: String!
  last: String!
  middle: String
  preferred: String
}

input NameCreateInput {
  first: String!
  last: String!
  middle: String
  preferred: String
}

input NameCreateOneInput {
  create: NameCreateInput
}

input NameUpdateDataInput {
  first: String
  last: String
  middle: String
  preferred: String
}

input NameUpdateOneRequiredInput {
  create: NameCreateInput
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
}

input NameUpsertNestedInput {
  create: NameCreateInput!
  update: NameUpdateDataInput!
}

input NameWhereInput {
  AND: [NameWhereInput!]
  first: String
  first_contains: String
  first_ends_with: String
  first_gt: String
  first_gte: String
  first_in: [String!]
  first_lt: String
  first_lte: String
  first_not: String
  first_not_contains: String
  first_not_ends_with: String
  first_not_in: [String!]
  first_not_starts_with: String
  first_starts_with: String
  last: String
  last_contains: String
  last_ends_with: String
  last_gt: String
  last_gte: String
  last_in: [String!]
  last_lt: String
  last_lte: String
  last_not: String
  last_not_contains: String
  last_not_ends_with: String
  last_not_in: [String!]
  last_not_starts_with: String
  last_starts_with: String
  middle: String
  middle_contains: String
  middle_ends_with: String
  middle_gt: String
  middle_gte: String
  middle_in: [String!]
  middle_lt: String
  middle_lte: String
  middle_not: String
  middle_not_contains: String
  middle_not_ends_with: String
  middle_not_in: [String!]
  middle_not_starts_with: String
  middle_starts_with: String
  preferred: String
  preferred_contains: String
  preferred_ends_with: String
  preferred_gt: String
  preferred_gte: String
  preferred_in: [String!]
  preferred_lt: String
  preferred_lte: String
  preferred_not: String
  preferred_not_contains: String
  preferred_not_ends_with: String
  preferred_not_in: [String!]
  preferred_not_starts_with: String
  preferred_starts_with: String
}

type Notification {
  _createdAt: DateTime!
  _id: ID!
  _sentAt: DateTime!
  message: String!
  receivedBy: [ReceivedBy!]
  receiver: [ID!]!
  sender: Sender!
  title: String!
}

input NotificationCreateInput {
  _id: ID
  _sentAt: DateTime!
  message: String!
  receivedBy: ReceivedByCreateManyInput
  receiver: NotificationCreatereceiverInput
  sender: SenderCreateOneInput!
  title: String!
}

input NotificationCreatereceiverInput {
  set: [ID!]
}

enum NotificationOrderByInput {
  _createdAt_ASC
  _createdAt_DESC
  _id_ASC
  _id_DESC
  _sentAt_ASC
  _sentAt_DESC
  message_ASC
  message_DESC
  title_ASC
  title_DESC
}

input NotificationUpdateInput {
  _sentAt: DateTime
  message: String
  receivedBy: ReceivedByUpdateManyInput
  receiver: NotificationUpdatereceiverInput
  sender: SenderUpdateOneRequiredInput
  title: String
}

input NotificationUpdatereceiverInput {
  set: [ID!]
}

input NotificationWhereInput {
  _createdAt: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_not: DateTime
  _createdAt_not_in: [DateTime!]
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  _sentAt: DateTime
  _sentAt_gt: DateTime
  _sentAt_gte: DateTime
  _sentAt_in: [DateTime!]
  _sentAt_lt: DateTime
  _sentAt_lte: DateTime
  _sentAt_not: DateTime
  _sentAt_not_in: [DateTime!]
  AND: [NotificationWhereInput!]
  message: String
  message_contains: String
  message_ends_with: String
  message_gt: String
  message_gte: String
  message_in: [String!]
  message_lt: String
  message_lte: String
  message_not: String
  message_not_contains: String
  message_not_ends_with: String
  message_not_in: [String!]
  message_not_starts_with: String
  message_starts_with: String
  receivedBy_every: ReceivedByRestrictedWhereInput
  receivedBy_none: ReceivedByRestrictedWhereInput
  receivedBy_some: ReceivedByWhereInput
  sender: SenderWhereInput
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input NotificationWhereUniqueInput {
  _id: ID
}

type Order {
  _id: ID!
  customer: Person!
  items(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]
  status: OrderStatus!
  total: Float!
}

input OrderCreateInput {
  _id: ID
  customer: PersonCreateOneInput!
  items: ProductCreateManyInput
  status: OrderStatus
  total: Float!
}

enum OrderOrderByInput {
  _id_ASC
  _id_DESC
  status_ASC
  status_DESC
  total_ASC
  total_DESC
}

enum OrderStatus {
  CART
  PAID
  WISH
}

input OrderUpdateInput {
  customer: PersonUpdateOneRequiredInput
  items: ProductUpdateManyInput
  status: OrderStatus
  total: Float
}

input OrderWhereInput {
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  AND: [OrderWhereInput!]
  customer: PersonWhereInput
  items_some: ProductWhereInput
  status: OrderStatus
  status_in: [OrderStatus!]
  status_not: OrderStatus
  status_not_in: [OrderStatus!]
  total: Float
  total_gt: Float
  total_gte: Float
  total_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_not: Float
  total_not_in: [Float!]
}

input OrderWhereUniqueInput {
  _id: ID
}

type Person {
  _createdAt: DateTime!
  _id: ID!
  _updatedAt: DateTime!
  billing: Billing
  career: Career
  connections(after: String, before: String, first: Int, last: Int, orderBy: PersonOrderByInput, skip: Int, where: PersonWhereInput): [Person!]
  contact: Contact
  name: Name!
  password: String!
  profile: Profile
  sessions: [Session!]
  type: PersonType!
  username: String!
}

input PersonCreateInput {
  _id: ID
  billing: BillingCreateOneInput
  career: CareerCreateOneInput
  connections: PersonCreateManyInput
  contact: ContactCreateOneInput
  name: NameCreateOneInput!
  password: String!
  profile: ProfileCreateOneInput
  sessions: SessionCreateManyInput
  type: PersonType
  username: String!
}

input PersonCreateManyInput {
  connect: [PersonWhereUniqueInput!]
  create: [PersonCreateInput!]
}

input PersonCreateOneInput {
  connect: PersonWhereUniqueInput
  create: PersonCreateInput
}

enum PersonOrderByInput {
  _createdAt_ASC
  _createdAt_DESC
  _id_ASC
  _id_DESC
  _updatedAt_ASC
  _updatedAt_DESC
  password_ASC
  password_DESC
  type_ASC
  type_DESC
  username_ASC
  username_DESC
}

input PersonScalarWhereInput {
  _createdAt: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_not: DateTime
  _createdAt_not_in: [DateTime!]
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  _updatedAt: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_not: DateTime
  _updatedAt_not_in: [DateTime!]
  AND: [PersonScalarWhereInput!]
  NOT: [PersonScalarWhereInput!]
  OR: [PersonScalarWhereInput!]
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  type: PersonType
  type_in: [PersonType!]
  type_not: PersonType
  type_not_in: [PersonType!]
  username: String
  username_contains: String
  username_ends_with: String
  username_gt: String
  username_gte: String
  username_in: [String!]
  username_lt: String
  username_lte: String
  username_not: String
  username_not_contains: String
  username_not_ends_with: String
  username_not_in: [String!]
  username_not_starts_with: String
  username_starts_with: String
}

enum PersonType {
  ADMINISTRATOR
  EMPLOYEE
  PARTNER
  USER
  VENDOR
}

input PersonUpdateDataInput {
  billing: BillingUpdateOneInput
  career: CareerUpdateOneInput
  connections: PersonUpdateManyInput
  contact: ContactUpdateOneInput
  name: NameUpdateOneRequiredInput
  password: String
  profile: ProfileUpdateOneInput
  sessions: SessionUpdateManyInput
  type: PersonType
  username: String
}

input PersonUpdateInput {
  billing: BillingUpdateOneInput
  career: CareerUpdateOneInput
  connections: PersonUpdateManyInput
  contact: ContactUpdateOneInput
  name: NameUpdateOneRequiredInput
  password: String
  profile: ProfileUpdateOneInput
  sessions: SessionUpdateManyInput
  type: PersonType
  username: String
}

input PersonUpdateManyDataInput {
  password: String
  type: PersonType
  username: String
}

input PersonUpdateManyInput {
  connect: [PersonWhereUniqueInput!]
  create: [PersonCreateInput!]
  delete: [PersonWhereUniqueInput!]
  deleteMany: [PersonScalarWhereInput!]
  disconnect: [PersonWhereUniqueInput!]
  set: [PersonWhereUniqueInput!]
  update: [PersonUpdateWithWhereUniqueNestedInput!]
  updateMany: [PersonUpdateManyWithWhereNestedInput!]
  upsert: [PersonUpsertWithWhereUniqueNestedInput!]
}

input PersonUpdateManyWithWhereNestedInput {
  data: PersonUpdateManyDataInput!
  where: PersonScalarWhereInput!
}

input PersonUpdateOneRequiredInput {
  connect: PersonWhereUniqueInput
  create: PersonCreateInput
  update: PersonUpdateDataInput
  upsert: PersonUpsertNestedInput
}

input PersonUpdateWithWhereUniqueNestedInput {
  data: PersonUpdateDataInput!
  where: PersonWhereUniqueInput!
}

input PersonUpsertNestedInput {
  create: PersonCreateInput!
  update: PersonUpdateDataInput!
}

input PersonUpsertWithWhereUniqueNestedInput {
  create: PersonCreateInput!
  update: PersonUpdateDataInput!
  where: PersonWhereUniqueInput!
}

input PersonWhereInput {
  _createdAt: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_not: DateTime
  _createdAt_not_in: [DateTime!]
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  _updatedAt: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_not: DateTime
  _updatedAt_not_in: [DateTime!]
  AND: [PersonWhereInput!]
  billing: BillingWhereInput
  career: CareerWhereInput
  connections_some: PersonWhereInput
  contact: ContactWhereInput
  name: NameWhereInput
  password: String
  password_contains: String
  password_ends_with: String
  password_gt: String
  password_gte: String
  password_in: [String!]
  password_lt: String
  password_lte: String
  password_not: String
  password_not_contains: String
  password_not_ends_with: String
  password_not_in: [String!]
  password_not_starts_with: String
  password_starts_with: String
  profile: ProfileWhereInput
  sessions_every: SessionRestrictedWhereInput
  sessions_none: SessionRestrictedWhereInput
  sessions_some: SessionWhereInput
  type: PersonType
  type_in: [PersonType!]
  type_not: PersonType
  type_not_in: [PersonType!]
  username: String
  username_contains: String
  username_ends_with: String
  username_gt: String
  username_gte: String
  username_in: [String!]
  username_lt: String
  username_lte: String
  username_not: String
  username_not_contains: String
  username_not_ends_with: String
  username_not_in: [String!]
  username_not_starts_with: String
  username_starts_with: String
}

input PersonWhereUniqueInput {
  _id: ID
  username: String
}

type Price {
  list: Float!
  retail: Float!
  savings: Float
  savingsPct: Float
}

input PriceCreateInput {
  list: Float!
  retail: Float!
  savings: Float
  savingsPct: Float
}

input PriceCreateOneInput {
  create: PriceCreateInput
}

input PriceUpdateDataInput {
  list: Float
  retail: Float
  savings: Float
  savingsPct: Float
}

input PriceUpdateOneRequiredInput {
  create: PriceCreateInput
  update: PriceUpdateDataInput
  upsert: PriceUpsertNestedInput
}

input PriceUpsertNestedInput {
  create: PriceCreateInput!
  update: PriceUpdateDataInput!
}

input PriceWhereInput {
  AND: [PriceWhereInput!]
  list: Float
  list_gt: Float
  list_gte: Float
  list_in: [Float!]
  list_lt: Float
  list_lte: Float
  list_not: Float
  list_not_in: [Float!]
  retail: Float
  retail_gt: Float
  retail_gte: Float
  retail_in: [Float!]
  retail_lt: Float
  retail_lte: Float
  retail_not: Float
  retail_not_in: [Float!]
  savings: Float
  savings_gt: Float
  savings_gte: Float
  savings_in: [Float!]
  savings_lt: Float
  savings_lte: Float
  savings_not: Float
  savings_not_in: [Float!]
  savingsPct: Float
  savingsPct_gt: Float
  savingsPct_gte: Float
  savingsPct_in: [Float!]
  savingsPct_lt: Float
  savingsPct_lte: Float
  savingsPct_not: Float
  savingsPct_not_in: [Float!]
}

type Product {
  _handlerId: ID!
  _id: ID!
  category: ProductCategory
  description: String!
  details: Json
  manufacturer: Manufacturer
  name: String!
  price: Price!
  quantity: Int!
  shipping: Shipping
  sku: String
}

enum ProductCategory {
  UNCATEGORIZED
}

input ProductCreateInput {
  _handlerId: ID
  _id: ID
  category: ProductCategory
  description: String!
  details: Json
  manufacturer: ManufacturerCreateOneInput
  name: String!
  price: PriceCreateOneInput!
  quantity: Int
  shipping: ShippingCreateOneInput
  sku: String
}

input ProductCreateManyInput {
  connect: [ProductWhereUniqueInput!]
  create: [ProductCreateInput!]
}

enum ProductOrderByInput {
  _handlerId_ASC
  _handlerId_DESC
  _id_ASC
  _id_DESC
  category_ASC
  category_DESC
  description_ASC
  description_DESC
  details_ASC
  details_DESC
  name_ASC
  name_DESC
  quantity_ASC
  quantity_DESC
  sku_ASC
  sku_DESC
}

input ProductScalarWhereInput {
  _handlerId: ID
  _handlerId_contains: ID
  _handlerId_ends_with: ID
  _handlerId_gt: ID
  _handlerId_gte: ID
  _handlerId_in: [ID!]
  _handlerId_lt: ID
  _handlerId_lte: ID
  _handlerId_not: ID
  _handlerId_not_contains: ID
  _handlerId_not_ends_with: ID
  _handlerId_not_in: [ID!]
  _handlerId_not_starts_with: ID
  _handlerId_starts_with: ID
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  AND: [ProductScalarWhereInput!]
  category: ProductCategory
  category_in: [ProductCategory!]
  category_not: ProductCategory
  category_not_in: [ProductCategory!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  quantity: Int
  quantity_gt: Int
  quantity_gte: Int
  quantity_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_not: Int
  quantity_not_in: [Int!]
  sku: String
  sku_contains: String
  sku_ends_with: String
  sku_gt: String
  sku_gte: String
  sku_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_not: String
  sku_not_contains: String
  sku_not_ends_with: String
  sku_not_in: [String!]
  sku_not_starts_with: String
  sku_starts_with: String
}

input ProductUpdateDataInput {
  category: ProductCategory
  description: String
  details: Json
  manufacturer: ManufacturerUpdateOneInput
  name: String
  price: PriceUpdateOneRequiredInput
  quantity: Int
  shipping: ShippingUpdateOneInput
  sku: String
}

input ProductUpdateInput {
  category: ProductCategory
  description: String
  details: Json
  manufacturer: ManufacturerUpdateOneInput
  name: String
  price: PriceUpdateOneRequiredInput
  quantity: Int
  shipping: ShippingUpdateOneInput
  sku: String
}

input ProductUpdateManyDataInput {
  category: ProductCategory
  description: String
  details: Json
  name: String
  quantity: Int
  sku: String
}

input ProductUpdateManyInput {
  connect: [ProductWhereUniqueInput!]
  create: [ProductCreateInput!]
  delete: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  disconnect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueNestedInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueNestedInput!]
}

input ProductUpdateManyWithWhereNestedInput {
  data: ProductUpdateManyDataInput!
  where: ProductScalarWhereInput!
}

input ProductUpdateWithWhereUniqueNestedInput {
  data: ProductUpdateDataInput!
  where: ProductWhereUniqueInput!
}

input ProductUpsertWithWhereUniqueNestedInput {
  create: ProductCreateInput!
  update: ProductUpdateDataInput!
  where: ProductWhereUniqueInput!
}

input ProductWhereInput {
  _handlerId: ID
  _handlerId_contains: ID
  _handlerId_ends_with: ID
  _handlerId_gt: ID
  _handlerId_gte: ID
  _handlerId_in: [ID!]
  _handlerId_lt: ID
  _handlerId_lte: ID
  _handlerId_not: ID
  _handlerId_not_contains: ID
  _handlerId_not_ends_with: ID
  _handlerId_not_in: [ID!]
  _handlerId_not_starts_with: ID
  _handlerId_starts_with: ID
  _id: ID
  _id_contains: ID
  _id_ends_with: ID
  _id_gt: ID
  _id_gte: ID
  _id_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_not: ID
  _id_not_contains: ID
  _id_not_ends_with: ID
  _id_not_in: [ID!]
  _id_not_starts_with: ID
  _id_starts_with: ID
  AND: [ProductWhereInput!]
  category: ProductCategory
  category_in: [ProductCategory!]
  category_not: ProductCategory
  category_not_in: [ProductCategory!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  manufacturer: ManufacturerWhereInput
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  price: PriceWhereInput
  quantity: Int
  quantity_gt: Int
  quantity_gte: Int
  quantity_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_not: Int
  quantity_not_in: [Int!]
  shipping: ShippingWhereInput
  sku: String
  sku_contains: String
  sku_ends_with: String
  sku_gt: String
  sku_gte: String
  sku_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_not: String
  sku_not_contains: String
  sku_not_ends_with: String
  sku_not_in: [String!]
  sku_not_starts_with: String
  sku_starts_with: String
}

input ProductWhereUniqueInput {
  _handlerId: ID
  _id: ID
  name: String
}

type Profile {
  avatar: String
  gender: Gender
  headline: String
}

input ProfileCreateInput {
  avatar: String
  gender: Gender
  headline: String
}

input ProfileCreateOneInput {
  create: ProfileCreateInput
}

input ProfileUpdateDataInput {
  avatar: String
  gender: Gender
  headline: String
}

input ProfileUpdateOneInput {
  create: ProfileCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
}

input ProfileUpsertNestedInput {
  create: ProfileCreateInput!
  update: ProfileUpdateDataInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  avatar: String
  avatar_contains: String
  avatar_ends_with: String
  avatar_gt: String
  avatar_gte: String
  avatar_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_not: String
  avatar_not_contains: String
  avatar_not_ends_with: String
  avatar_not_in: [String!]
  avatar_not_starts_with: String
  avatar_starts_with: String
  gender: Gender
  gender_in: [Gender!]
  gender_not: Gender
  gender_not_in: [Gender!]
  headline: String
  headline_contains: String
  headline_ends_with: String
  headline_gt: String
  headline_gte: String
  headline_in: [String!]
  headline_lt: String
  headline_lte: String
  headline_not: String
  headline_not_contains: String
  headline_not_ends_with: String
  headline_not_in: [String!]
  headline_not_starts_with: String
  headline_starts_with: String
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderByInput, skip: Int, where: CommentWhereInput): [Comment!]!
  document(where: DocumentWhereUniqueInput!): Document
  documents(after: String, before: String, first: Int, last: Int, orderBy: DocumentOrderByInput, skip: Int, where: DocumentWhereInput): [Document!]!
  notification(where: NotificationWhereUniqueInput!): Notification
  notifications(after: String, before: String, first: Int, last: Int, orderBy: NotificationOrderByInput, skip: Int, where: NotificationWhereInput): [Notification!]!
  order(where: OrderWhereUniqueInput!): Order
  orders(after: String, before: String, first: Int, last: Int, orderBy: OrderOrderByInput, skip: Int, where: OrderWhereInput): [Order!]!
  person(where: PersonWhereUniqueInput!): Person
  persons(after: String, before: String, first: Int, last: Int, orderBy: PersonOrderByInput, skip: Int, where: PersonWhereInput): [Person!]!
  product(where: ProductWhereUniqueInput!): Product
  products(after: String, before: String, first: Int, last: Int, orderBy: ProductOrderByInput, skip: Int, where: ProductWhereInput): [Product!]!
}

type ReceivedBy {
  _personId: Person!
  _readAt: DateTime!
  _receivedAt: DateTime!
}

input ReceivedByCreateInput {
  _personId: PersonCreateOneInput!
  _readAt: DateTime!
  _receivedAt: DateTime!
}

input ReceivedByCreateManyInput {
  create: [ReceivedByCreateInput!]
}

input ReceivedByRestrictedWhereInput {
  _readAt: DateTime
  _readAt_gt: DateTime
  _readAt_gte: DateTime
  _readAt_in: [DateTime!]
  _readAt_lt: DateTime
  _readAt_lte: DateTime
  _readAt_not: DateTime
  _readAt_not_in: [DateTime!]
  _receivedAt: DateTime
  _receivedAt_gt: DateTime
  _receivedAt_gte: DateTime
  _receivedAt_in: [DateTime!]
  _receivedAt_lt: DateTime
  _receivedAt_lte: DateTime
  _receivedAt_not: DateTime
  _receivedAt_not_in: [DateTime!]
  AND: [ReceivedByRestrictedWhereInput!]
}

input ReceivedByScalarWhereInput {
  _readAt: DateTime
  _readAt_gt: DateTime
  _readAt_gte: DateTime
  _readAt_in: [DateTime!]
  _readAt_lt: DateTime
  _readAt_lte: DateTime
  _readAt_not: DateTime
  _readAt_not_in: [DateTime!]
  _receivedAt: DateTime
  _receivedAt_gt: DateTime
  _receivedAt_gte: DateTime
  _receivedAt_in: [DateTime!]
  _receivedAt_lt: DateTime
  _receivedAt_lte: DateTime
  _receivedAt_not: DateTime
  _receivedAt_not_in: [DateTime!]
  AND: [ReceivedByScalarWhereInput!]
  NOT: [ReceivedByScalarWhereInput!]
  OR: [ReceivedByScalarWhereInput!]
}

input ReceivedByUpdateManyDataInput {
  _readAt: DateTime
  _receivedAt: DateTime
}

input ReceivedByUpdateManyInput {
  create: [ReceivedByCreateInput!]
  deleteMany: [ReceivedByScalarWhereInput!]
  updateMany: [ReceivedByUpdateManyWithWhereNestedInput!]
}

input ReceivedByUpdateManyWithWhereNestedInput {
  data: ReceivedByUpdateManyDataInput!
  where: ReceivedByScalarWhereInput!
}

input ReceivedByWhereInput {
  _personId: PersonWhereInput
  _readAt: DateTime
  _readAt_gt: DateTime
  _readAt_gte: DateTime
  _readAt_in: [DateTime!]
  _readAt_lt: DateTime
  _readAt_lte: DateTime
  _readAt_not: DateTime
  _readAt_not_in: [DateTime!]
  _receivedAt: DateTime
  _receivedAt_gt: DateTime
  _receivedAt_gte: DateTime
  _receivedAt_in: [DateTime!]
  _receivedAt_lt: DateTime
  _receivedAt_lte: DateTime
  _receivedAt_not: DateTime
  _receivedAt_not_in: [DateTime!]
  AND: [ReceivedByWhereInput!]
}

type Sender {
  _personId: Person!
  name: String!
  type: SenderType!
}

input SenderCreateInput {
  _personId: PersonCreateOneInput!
  name: String!
  type: SenderType!
}

input SenderCreateOneInput {
  create: SenderCreateInput
}

enum SenderType {
  PERSON
  SYSTEM
}

input SenderUpdateDataInput {
  _personId: PersonUpdateOneRequiredInput
  name: String
  type: SenderType
}

input SenderUpdateOneRequiredInput {
  create: SenderCreateInput
  update: SenderUpdateDataInput
  upsert: SenderUpsertNestedInput
}

input SenderUpsertNestedInput {
  create: SenderCreateInput!
  update: SenderUpdateDataInput!
}

input SenderWhereInput {
  _personId: PersonWhereInput
  AND: [SenderWhereInput!]
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  type: SenderType
  type_in: [SenderType!]
  type_not: SenderType
  type_not_in: [SenderType!]
}

type Session {
  device: String
  location: String
  token: String
}

input SessionCreateInput {
  device: String
  location: String
  token: String
}

input SessionCreateManyInput {
  create: [SessionCreateInput!]
}

input SessionRestrictedWhereInput {
  AND: [SessionRestrictedWhereInput!]
  device: String
  device_contains: String
  device_ends_with: String
  device_gt: String
  device_gte: String
  device_in: [String!]
  device_lt: String
  device_lte: String
  device_not: String
  device_not_contains: String
  device_not_ends_with: String
  device_not_in: [String!]
  device_not_starts_with: String
  device_starts_with: String
  location: String
  location_contains: String
  location_ends_with: String
  location_gt: String
  location_gte: String
  location_in: [String!]
  location_lt: String
  location_lte: String
  location_not: String
  location_not_contains: String
  location_not_ends_with: String
  location_not_in: [String!]
  location_not_starts_with: String
  location_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
}

input SessionScalarWhereInput {
  AND: [SessionScalarWhereInput!]
  device: String
  device_contains: String
  device_ends_with: String
  device_gt: String
  device_gte: String
  device_in: [String!]
  device_lt: String
  device_lte: String
  device_not: String
  device_not_contains: String
  device_not_ends_with: String
  device_not_in: [String!]
  device_not_starts_with: String
  device_starts_with: String
  location: String
  location_contains: String
  location_ends_with: String
  location_gt: String
  location_gte: String
  location_in: [String!]
  location_lt: String
  location_lte: String
  location_not: String
  location_not_contains: String
  location_not_ends_with: String
  location_not_in: [String!]
  location_not_starts_with: String
  location_starts_with: String
  NOT: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
}

input SessionUpdateManyDataInput {
  device: String
  location: String
  token: String
}

input SessionUpdateManyInput {
  create: [SessionCreateInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  data: SessionUpdateManyDataInput!
  where: SessionScalarWhereInput!
}

input SessionWhereInput {
  AND: [SessionWhereInput!]
  device: String
  device_contains: String
  device_ends_with: String
  device_gt: String
  device_gte: String
  device_in: [String!]
  device_lt: String
  device_lte: String
  device_not: String
  device_not_contains: String
  device_not_ends_with: String
  device_not_in: [String!]
  device_not_starts_with: String
  device_starts_with: String
  location: String
  location_contains: String
  location_ends_with: String
  location_gt: String
  location_gte: String
  location_in: [String!]
  location_lt: String
  location_lte: String
  location_not: String
  location_not_contains: String
  location_not_ends_with: String
  location_not_in: [String!]
  location_not_starts_with: String
  location_starts_with: String
  token: String
  token_contains: String
  token_ends_with: String
  token_gt: String
  token_gte: String
  token_in: [String!]
  token_lt: String
  token_lte: String
  token_not: String
  token_not_contains: String
  token_not_ends_with: String
  token_not_in: [String!]
  token_not_starts_with: String
  token_starts_with: String
}

type Shipping {
  depth: Float!
  height: Float!
  scale: DimensionScale!
  weight: Float!
  width: Float!
}

input ShippingCreateInput {
  depth: Float!
  height: Float!
  scale: DimensionScale
  weight: Float!
  width: Float!
}

input ShippingCreateOneInput {
  create: ShippingCreateInput
}

input ShippingUpdateDataInput {
  depth: Float
  height: Float
  scale: DimensionScale
  weight: Float
  width: Float
}

input ShippingUpdateOneInput {
  create: ShippingCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ShippingUpdateDataInput
  upsert: ShippingUpsertNestedInput
}

input ShippingUpsertNestedInput {
  create: ShippingCreateInput!
  update: ShippingUpdateDataInput!
}

input ShippingWhereInput {
  AND: [ShippingWhereInput!]
  depth: Float
  depth_gt: Float
  depth_gte: Float
  depth_in: [Float!]
  depth_lt: Float
  depth_lte: Float
  depth_not: Float
  depth_not_in: [Float!]
  height: Float
  height_gt: Float
  height_gte: Float
  height_in: [Float!]
  height_lt: Float
  height_lte: Float
  height_not: Float
  height_not_in: [Float!]
  scale: DimensionScale
  scale_in: [DimensionScale!]
  scale_not: DimensionScale
  scale_not_in: [DimensionScale!]
  weight: Float
  weight_gt: Float
  weight_gte: Float
  weight_in: [Float!]
  weight_lt: Float
  weight_lte: Float
  weight_not: Float
  weight_not_in: [Float!]
  width: Float
  width_gt: Float
  width_gte: Float
  width_in: [Float!]
  width_lt: Float
  width_lte: Float
  width_not: Float
  width_not_in: [Float!]
}
