// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Account {
  number: Int!
  routing: Int!
  type: AccountType!
}

input AccountCreateInput {
  number: Int!
  routing: Int!
  type: AccountType!
}

input AccountCreateManyInput {
  create: [AccountCreateInput!]
}

input AccountRestrictedWhereInput {
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  routing: Int
  routing_not: Int
  routing_in: [Int!]
  routing_not_in: [Int!]
  routing_lt: Int
  routing_lte: Int
  routing_gt: Int
  routing_gte: Int
  type: AccountType
  type_not: AccountType
  type_in: [AccountType!]
  type_not_in: [AccountType!]
  AND: [AccountRestrictedWhereInput!]
}

input AccountScalarWhereInput {
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  routing: Int
  routing_not: Int
  routing_in: [Int!]
  routing_not_in: [Int!]
  routing_lt: Int
  routing_lte: Int
  routing_gt: Int
  routing_gte: Int
  type: AccountType
  type_not: AccountType
  type_in: [AccountType!]
  type_not_in: [AccountType!]
  AND: [AccountScalarWhereInput!]
  OR: [AccountScalarWhereInput!]
  NOT: [AccountScalarWhereInput!]
}

enum AccountType {
  CHECKING
  SAVINGS
}

input AccountUpdateManyDataInput {
  number: Int
  routing: Int
  type: AccountType
}

input AccountUpdateManyInput {
  create: [AccountCreateInput!]
  deleteMany: [AccountScalarWhereInput!]
  updateMany: [AccountUpdateManyWithWhereNestedInput!]
}

input AccountUpdateManyWithWhereNestedInput {
  where: AccountScalarWhereInput!
  data: AccountUpdateManyDataInput!
}

input AccountWhereInput {
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  routing: Int
  routing_not: Int
  routing_in: [Int!]
  routing_not_in: [Int!]
  routing_lt: Int
  routing_lte: Int
  routing_gt: Int
  routing_gte: Int
  type: AccountType
  type_not: AccountType
  type_in: [AccountType!]
  type_not_in: [AccountType!]
  AND: [AccountWhereInput!]
}

type AggregateComment {
  count: Int!
}

type AggregateDocument {
  count: Int!
}

type AggregateNotification {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePerson {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Billing {
  accounts: [Account!]
  cards: [Card!]
}

input BillingCreateInput {
  accounts: AccountCreateManyInput
  cards: CardCreateManyInput
}

input BillingCreateOneInput {
  create: BillingCreateInput
}

input BillingUpdateDataInput {
  accounts: AccountUpdateManyInput
  cards: CardUpdateManyInput
}

input BillingUpdateOneInput {
  create: BillingCreateInput
  update: BillingUpdateDataInput
  upsert: BillingUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input BillingUpsertNestedInput {
  update: BillingUpdateDataInput!
  create: BillingCreateInput!
}

input BillingWhereInput {
  accounts_some: AccountWhereInput
  accounts_every: AccountRestrictedWhereInput
  accounts_none: AccountRestrictedWhereInput
  cards_some: CardWhereInput
  cards_every: CardRestrictedWhereInput
  cards_none: CardRestrictedWhereInput
  AND: [BillingWhereInput!]
}

type Card {
  name: String!
  number: Int!
  cvv: Int!
  expiration: DateTime!
  type: CardType!
}

input CardCreateInput {
  name: String!
  number: Int!
  cvv: Int!
  expiration: DateTime!
  type: CardType!
}

input CardCreateManyInput {
  create: [CardCreateInput!]
}

input CardRestrictedWhereInput {
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  cvv: Int
  cvv_not: Int
  cvv_in: [Int!]
  cvv_not_in: [Int!]
  cvv_lt: Int
  cvv_lte: Int
  cvv_gt: Int
  cvv_gte: Int
  expiration: DateTime
  expiration_not: DateTime
  expiration_in: [DateTime!]
  expiration_not_in: [DateTime!]
  expiration_lt: DateTime
  expiration_lte: DateTime
  expiration_gt: DateTime
  expiration_gte: DateTime
  type: CardType
  type_not: CardType
  type_in: [CardType!]
  type_not_in: [CardType!]
  AND: [CardRestrictedWhereInput!]
}

input CardScalarWhereInput {
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  cvv: Int
  cvv_not: Int
  cvv_in: [Int!]
  cvv_not_in: [Int!]
  cvv_lt: Int
  cvv_lte: Int
  cvv_gt: Int
  cvv_gte: Int
  expiration: DateTime
  expiration_not: DateTime
  expiration_in: [DateTime!]
  expiration_not_in: [DateTime!]
  expiration_lt: DateTime
  expiration_lte: DateTime
  expiration_gt: DateTime
  expiration_gte: DateTime
  type: CardType
  type_not: CardType
  type_in: [CardType!]
  type_not_in: [CardType!]
  AND: [CardScalarWhereInput!]
  OR: [CardScalarWhereInput!]
  NOT: [CardScalarWhereInput!]
}

enum CardType {
  CREDIT
  DEBIT
}

input CardUpdateManyDataInput {
  name: String
  number: Int
  cvv: Int
  expiration: DateTime
  type: CardType
}

input CardUpdateManyInput {
  create: [CardCreateInput!]
  deleteMany: [CardScalarWhereInput!]
  updateMany: [CardUpdateManyWithWhereNestedInput!]
}

input CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput!
  data: CardUpdateManyDataInput!
}

input CardWhereInput {
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  number: Int
  number_not: Int
  number_in: [Int!]
  number_not_in: [Int!]
  number_lt: Int
  number_lte: Int
  number_gt: Int
  number_gte: Int
  cvv: Int
  cvv_not: Int
  cvv_in: [Int!]
  cvv_not_in: [Int!]
  cvv_lt: Int
  cvv_lte: Int
  cvv_gt: Int
  cvv_gte: Int
  expiration: DateTime
  expiration_not: DateTime
  expiration_in: [DateTime!]
  expiration_not_in: [DateTime!]
  expiration_lt: DateTime
  expiration_lte: DateTime
  expiration_gt: DateTime
  expiration_gte: DateTime
  type: CardType
  type_not: CardType
  type_in: [CardType!]
  type_not_in: [CardType!]
  AND: [CardWhereInput!]
}

type Career {
  company: String!
  experience: [Experience!]
  position: String!
}

input CareerCreateInput {
  company: String!
  experience: ExperienceCreateManyInput
  position: String!
}

input CareerCreateOneInput {
  create: CareerCreateInput
}

input CareerUpdateDataInput {
  company: String
  experience: ExperienceUpdateManyInput
  position: String
}

input CareerUpdateOneInput {
  create: CareerCreateInput
  update: CareerUpdateDataInput
  upsert: CareerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input CareerUpsertNestedInput {
  update: CareerUpdateDataInput!
  create: CareerCreateInput!
}

input CareerWhereInput {
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  experience_some: ExperienceWhereInput
  experience_every: ExperienceRestrictedWhereInput
  experience_none: ExperienceRestrictedWhereInput
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  AND: [CareerWhereInput!]
}

type Comment {
  _id: ID!
  _createdAt: DateTime!
  _discussionId: ID!
  _parentId: Comment
  _updatedAt: DateTime!
  author: Person!
  content: String!
  fullSlug: String
  slug: String
  type: CommentType
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  _id: ID
  _discussionId: ID!
  _parentId: CommentCreateOneInput
  author: PersonCreateOneInput!
  content: String!
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentCreateOneInput {
  create: CommentCreateInput
  connect: CommentWhereUniqueInput
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  _id_ASC
  _id_DESC
  _createdAt_ASC
  _createdAt_DESC
  _discussionId_ASC
  _discussionId_DESC
  _updatedAt_ASC
  _updatedAt_DESC
  content_ASC
  content_DESC
  fullSlug_ASC
  fullSlug_DESC
  slug_ASC
  slug_DESC
  type_ASC
  type_DESC
}

type CommentPreviousValues {
  _id: ID!
  _createdAt: DateTime!
  _discussionId: ID!
  _updatedAt: DateTime!
  content: String!
  fullSlug: String
  slug: String
  type: CommentType
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
}

enum CommentType {
  CONVERSATION
  REVIEW
}

input CommentUpdateDataInput {
  _discussionId: ID
  _parentId: CommentUpdateOneInput
  author: PersonUpdateOneRequiredInput
  content: String
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentUpdateInput {
  _discussionId: ID
  _parentId: CommentUpdateOneInput
  author: PersonUpdateOneRequiredInput
  content: String
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentUpdateManyMutationInput {
  _discussionId: ID
  content: String
  fullSlug: String
  slug: String
  type: CommentType
}

input CommentUpdateOneInput {
  create: CommentCreateInput
  update: CommentUpdateDataInput
  upsert: CommentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CommentWhereUniqueInput
}

input CommentUpsertNestedInput {
  update: CommentUpdateDataInput!
  create: CommentCreateInput!
}

input CommentWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _createdAt: DateTime
  _createdAt_not: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_not_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _discussionId: ID
  _discussionId_not: ID
  _discussionId_in: [ID!]
  _discussionId_not_in: [ID!]
  _discussionId_lt: ID
  _discussionId_lte: ID
  _discussionId_gt: ID
  _discussionId_gte: ID
  _discussionId_contains: ID
  _discussionId_not_contains: ID
  _discussionId_starts_with: ID
  _discussionId_not_starts_with: ID
  _discussionId_ends_with: ID
  _discussionId_not_ends_with: ID
  _parentId: CommentWhereInput
  _updatedAt: DateTime
  _updatedAt_not: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_not_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  author: PersonWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  fullSlug: String
  fullSlug_not: String
  fullSlug_in: [String!]
  fullSlug_not_in: [String!]
  fullSlug_lt: String
  fullSlug_lte: String
  fullSlug_gt: String
  fullSlug_gte: String
  fullSlug_contains: String
  fullSlug_not_contains: String
  fullSlug_starts_with: String
  fullSlug_not_starts_with: String
  fullSlug_ends_with: String
  fullSlug_not_ends_with: String
  slug: String
  slug_not: String
  slug_in: [String!]
  slug_not_in: [String!]
  slug_lt: String
  slug_lte: String
  slug_gt: String
  slug_gte: String
  slug_contains: String
  slug_not_contains: String
  slug_starts_with: String
  slug_not_starts_with: String
  slug_ends_with: String
  slug_not_ends_with: String
  type: CommentType
  type_not: CommentType
  type_in: [CommentType!]
  type_not_in: [CommentType!]
  AND: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  _id: ID
  fullSlug: String
}

type Contact {
  emails: [String!]!
  address1: String!
  address2: String!
  city: String!
  state: String!
  country: String!
  postalCode: String!
  phones: [String!]!
}

input ContactCreateemailsInput {
  set: [String!]
}

input ContactCreateInput {
  emails: ContactCreateemailsInput
  address1: String!
  address2: String!
  city: String!
  state: String!
  country: String!
  postalCode: String!
  phones: ContactCreatephonesInput
}

input ContactCreateOneInput {
  create: ContactCreateInput
}

input ContactCreatephonesInput {
  set: [String!]
}

input ContactUpdateDataInput {
  emails: ContactUpdateemailsInput
  address1: String
  address2: String
  city: String
  state: String
  country: String
  postalCode: String
  phones: ContactUpdatephonesInput
}

input ContactUpdateemailsInput {
  set: [String!]
}

input ContactUpdateOneInput {
  create: ContactCreateInput
  update: ContactUpdateDataInput
  upsert: ContactUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input ContactUpdatephonesInput {
  set: [String!]
}

input ContactUpsertNestedInput {
  update: ContactUpdateDataInput!
  create: ContactCreateInput!
}

input ContactWhereInput {
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  AND: [ContactWhereInput!]
}

scalar DateTime

enum DimensionScale {
  FOOT
  METER
}

type Document {
  _id: ID!
  _createdAt: DateTime!
  _publishedAt: DateTime
  _updatedAt: DateTime!
  author: Person!
  category: DocumentCategory!
  content: String!
  subtitle: String
  title: String!
  type: DocumentType!
}

enum DocumentCategory {
  UNCATEGORIZED
  CORPORATE
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]!
  aggregate: AggregateDocument!
}

input DocumentCreateInput {
  _id: ID
  _publishedAt: DateTime
  author: PersonCreateOneInput!
  category: DocumentCategory
  content: String!
  subtitle: String
  title: String!
  type: DocumentType
}

type DocumentEdge {
  node: Document!
  cursor: String!
}

enum DocumentOrderByInput {
  _id_ASC
  _id_DESC
  _createdAt_ASC
  _createdAt_DESC
  _publishedAt_ASC
  _publishedAt_DESC
  _updatedAt_ASC
  _updatedAt_DESC
  category_ASC
  category_DESC
  content_ASC
  content_DESC
  subtitle_ASC
  subtitle_DESC
  title_ASC
  title_DESC
  type_ASC
  type_DESC
}

type DocumentPreviousValues {
  _id: ID!
  _createdAt: DateTime!
  _publishedAt: DateTime
  _updatedAt: DateTime!
  category: DocumentCategory!
  content: String!
  subtitle: String
  title: String!
  type: DocumentType!
}

type DocumentSubscriptionPayload {
  mutation: MutationType!
  node: Document
  updatedFields: [String!]
  previousValues: DocumentPreviousValues
}

input DocumentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentWhereInput
  AND: [DocumentSubscriptionWhereInput!]
}

enum DocumentType {
  DEFAULT
  INSIGHT
  POLICY
}

input DocumentUpdateInput {
  _publishedAt: DateTime
  author: PersonUpdateOneRequiredInput
  category: DocumentCategory
  content: String
  subtitle: String
  title: String
  type: DocumentType
}

input DocumentUpdateManyMutationInput {
  _publishedAt: DateTime
  category: DocumentCategory
  content: String
  subtitle: String
  title: String
  type: DocumentType
}

input DocumentWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _createdAt: DateTime
  _createdAt_not: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_not_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _publishedAt: DateTime
  _publishedAt_not: DateTime
  _publishedAt_in: [DateTime!]
  _publishedAt_not_in: [DateTime!]
  _publishedAt_lt: DateTime
  _publishedAt_lte: DateTime
  _publishedAt_gt: DateTime
  _publishedAt_gte: DateTime
  _updatedAt: DateTime
  _updatedAt_not: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_not_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  author: PersonWhereInput
  category: DocumentCategory
  category_not: DocumentCategory
  category_in: [DocumentCategory!]
  category_not_in: [DocumentCategory!]
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  subtitle: String
  subtitle_not: String
  subtitle_in: [String!]
  subtitle_not_in: [String!]
  subtitle_lt: String
  subtitle_lte: String
  subtitle_gt: String
  subtitle_gte: String
  subtitle_contains: String
  subtitle_not_contains: String
  subtitle_starts_with: String
  subtitle_not_starts_with: String
  subtitle_ends_with: String
  subtitle_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  type: DocumentType
  type_not: DocumentType
  type_in: [DocumentType!]
  type_not_in: [DocumentType!]
  AND: [DocumentWhereInput!]
}

input DocumentWhereUniqueInput {
  _id: ID
  title: String
}

type Experience {
  company: String!
  position: String!
  description: String
  start: DateTime!
  end: DateTime!
}

input ExperienceCreateInput {
  company: String!
  position: String!
  description: String
  start: DateTime!
  end: DateTime!
}

input ExperienceCreateManyInput {
  create: [ExperienceCreateInput!]
}

input ExperienceRestrictedWhereInput {
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  start: DateTime
  start_not: DateTime
  start_in: [DateTime!]
  start_not_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_gt: DateTime
  start_gte: DateTime
  end: DateTime
  end_not: DateTime
  end_in: [DateTime!]
  end_not_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_gt: DateTime
  end_gte: DateTime
  AND: [ExperienceRestrictedWhereInput!]
}

input ExperienceScalarWhereInput {
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  start: DateTime
  start_not: DateTime
  start_in: [DateTime!]
  start_not_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_gt: DateTime
  start_gte: DateTime
  end: DateTime
  end_not: DateTime
  end_in: [DateTime!]
  end_not_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_gt: DateTime
  end_gte: DateTime
  AND: [ExperienceScalarWhereInput!]
  OR: [ExperienceScalarWhereInput!]
  NOT: [ExperienceScalarWhereInput!]
}

input ExperienceUpdateManyDataInput {
  company: String
  position: String
  description: String
  start: DateTime
  end: DateTime
}

input ExperienceUpdateManyInput {
  create: [ExperienceCreateInput!]
  deleteMany: [ExperienceScalarWhereInput!]
  updateMany: [ExperienceUpdateManyWithWhereNestedInput!]
}

input ExperienceUpdateManyWithWhereNestedInput {
  where: ExperienceScalarWhereInput!
  data: ExperienceUpdateManyDataInput!
}

input ExperienceWhereInput {
  company: String
  company_not: String
  company_in: [String!]
  company_not_in: [String!]
  company_lt: String
  company_lte: String
  company_gt: String
  company_gte: String
  company_contains: String
  company_not_contains: String
  company_starts_with: String
  company_not_starts_with: String
  company_ends_with: String
  company_not_ends_with: String
  position: String
  position_not: String
  position_in: [String!]
  position_not_in: [String!]
  position_lt: String
  position_lte: String
  position_gt: String
  position_gte: String
  position_contains: String
  position_not_contains: String
  position_starts_with: String
  position_not_starts_with: String
  position_ends_with: String
  position_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  start: DateTime
  start_not: DateTime
  start_in: [DateTime!]
  start_not_in: [DateTime!]
  start_lt: DateTime
  start_lte: DateTime
  start_gt: DateTime
  start_gte: DateTime
  end: DateTime
  end_not: DateTime
  end_in: [DateTime!]
  end_not_in: [DateTime!]
  end_lt: DateTime
  end_lte: DateTime
  end_gt: DateTime
  end_gte: DateTime
  AND: [ExperienceWhereInput!]
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

scalar Json

scalar Long

type Manufacturer {
  model: String!
  releaseDate: DateTime!
}

input ManufacturerCreateInput {
  model: String!
  releaseDate: DateTime!
}

input ManufacturerCreateOneInput {
  create: ManufacturerCreateInput
}

input ManufacturerUpdateDataInput {
  model: String
  releaseDate: DateTime
}

input ManufacturerUpdateOneInput {
  create: ManufacturerCreateInput
  update: ManufacturerUpdateDataInput
  upsert: ManufacturerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input ManufacturerUpsertNestedInput {
  update: ManufacturerUpdateDataInput!
  create: ManufacturerCreateInput!
}

input ManufacturerWhereInput {
  model: String
  model_not: String
  model_in: [String!]
  model_not_in: [String!]
  model_lt: String
  model_lte: String
  model_gt: String
  model_gte: String
  model_contains: String
  model_not_contains: String
  model_starts_with: String
  model_not_starts_with: String
  model_ends_with: String
  model_not_ends_with: String
  releaseDate: DateTime
  releaseDate_not: DateTime
  releaseDate_in: [DateTime!]
  releaseDate_not_in: [DateTime!]
  releaseDate_lt: DateTime
  releaseDate_lte: DateTime
  releaseDate_gt: DateTime
  releaseDate_gte: DateTime
  AND: [ManufacturerWhereInput!]
}

type Mutation {
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createDocument(data: DocumentCreateInput!): Document!
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateManyDocuments(data: DocumentUpdateManyMutationInput!, where: DocumentWhereInput): BatchPayload!
  upsertDocument(where: DocumentWhereUniqueInput!, create: DocumentCreateInput!, update: DocumentUpdateInput!): Document!
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteManyDocuments(where: DocumentWhereInput): BatchPayload!
  createNotification(data: NotificationCreateInput!): Notification!
  updateNotification(data: NotificationUpdateInput!, where: NotificationWhereUniqueInput!): Notification
  updateManyNotifications(data: NotificationUpdateManyMutationInput!, where: NotificationWhereInput): BatchPayload!
  upsertNotification(where: NotificationWhereUniqueInput!, create: NotificationCreateInput!, update: NotificationUpdateInput!): Notification!
  deleteNotification(where: NotificationWhereUniqueInput!): Notification
  deleteManyNotifications(where: NotificationWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPerson(data: PersonCreateInput!): Person!
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateManyPersons(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): BatchPayload!
  upsertPerson(where: PersonWhereUniqueInput!, create: PersonCreateInput!, update: PersonUpdateInput!): Person!
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteManyPersons(where: PersonWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Name {
  first: String!
  last: String!
  middle: String
  preferred: String
}

input NameCreateInput {
  first: String!
  last: String!
  middle: String
  preferred: String
}

input NameCreateOneInput {
  create: NameCreateInput
}

input NameUpdateDataInput {
  first: String
  last: String
  middle: String
  preferred: String
}

input NameUpdateOneRequiredInput {
  create: NameCreateInput
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
}

input NameUpsertNestedInput {
  update: NameUpdateDataInput!
  create: NameCreateInput!
}

input NameWhereInput {
  first: String
  first_not: String
  first_in: [String!]
  first_not_in: [String!]
  first_lt: String
  first_lte: String
  first_gt: String
  first_gte: String
  first_contains: String
  first_not_contains: String
  first_starts_with: String
  first_not_starts_with: String
  first_ends_with: String
  first_not_ends_with: String
  last: String
  last_not: String
  last_in: [String!]
  last_not_in: [String!]
  last_lt: String
  last_lte: String
  last_gt: String
  last_gte: String
  last_contains: String
  last_not_contains: String
  last_starts_with: String
  last_not_starts_with: String
  last_ends_with: String
  last_not_ends_with: String
  middle: String
  middle_not: String
  middle_in: [String!]
  middle_not_in: [String!]
  middle_lt: String
  middle_lte: String
  middle_gt: String
  middle_gte: String
  middle_contains: String
  middle_not_contains: String
  middle_starts_with: String
  middle_not_starts_with: String
  middle_ends_with: String
  middle_not_ends_with: String
  preferred: String
  preferred_not: String
  preferred_in: [String!]
  preferred_not_in: [String!]
  preferred_lt: String
  preferred_lte: String
  preferred_gt: String
  preferred_gte: String
  preferred_contains: String
  preferred_not_contains: String
  preferred_starts_with: String
  preferred_not_starts_with: String
  preferred_ends_with: String
  preferred_not_ends_with: String
  AND: [NameWhereInput!]
}

interface Node {
  id: ID!
}

type Notification {
  _id: ID!
  _createdAt: DateTime!
  _sentAt: DateTime!
  receiver: [ID!]!
  message: String!
  receivedBy: [ReceivedBy!]
  sender: Sender!
  title: String!
}

type NotificationConnection {
  pageInfo: PageInfo!
  edges: [NotificationEdge]!
  aggregate: AggregateNotification!
}

input NotificationCreateInput {
  _id: ID
  _sentAt: DateTime!
  receiver: NotificationCreatereceiverInput
  message: String!
  receivedBy: ReceivedByCreateManyInput
  sender: SenderCreateOneInput!
  title: String!
}

input NotificationCreatereceiverInput {
  set: [ID!]
}

type NotificationEdge {
  node: Notification!
  cursor: String!
}

enum NotificationOrderByInput {
  _id_ASC
  _id_DESC
  _createdAt_ASC
  _createdAt_DESC
  _sentAt_ASC
  _sentAt_DESC
  message_ASC
  message_DESC
  title_ASC
  title_DESC
}

type NotificationPreviousValues {
  _id: ID!
  _createdAt: DateTime!
  _sentAt: DateTime!
  receiver: [ID!]!
  message: String!
  title: String!
}

type NotificationSubscriptionPayload {
  mutation: MutationType!
  node: Notification
  updatedFields: [String!]
  previousValues: NotificationPreviousValues
}

input NotificationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NotificationWhereInput
  AND: [NotificationSubscriptionWhereInput!]
}

input NotificationUpdateInput {
  _sentAt: DateTime
  receiver: NotificationUpdatereceiverInput
  message: String
  receivedBy: ReceivedByUpdateManyInput
  sender: SenderUpdateOneRequiredInput
  title: String
}

input NotificationUpdateManyMutationInput {
  _sentAt: DateTime
  receiver: NotificationUpdatereceiverInput
  message: String
  title: String
}

input NotificationUpdatereceiverInput {
  set: [ID!]
}

input NotificationWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _createdAt: DateTime
  _createdAt_not: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_not_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _sentAt: DateTime
  _sentAt_not: DateTime
  _sentAt_in: [DateTime!]
  _sentAt_not_in: [DateTime!]
  _sentAt_lt: DateTime
  _sentAt_lte: DateTime
  _sentAt_gt: DateTime
  _sentAt_gte: DateTime
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  receivedBy_some: ReceivedByWhereInput
  receivedBy_every: ReceivedByRestrictedWhereInput
  receivedBy_none: ReceivedByRestrictedWhereInput
  sender: SenderWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [NotificationWhereInput!]
}

input NotificationWhereUniqueInput {
  _id: ID
}

type Order {
  _id: ID!
  customer: Person!
  items(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product!]
  total: Float!
  status: OrderStatus!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  _id: ID
  customer: PersonCreateOneInput!
  items: ProductCreateManyInput
  total: Float!
  status: OrderStatus
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  _id_ASC
  _id_DESC
  total_ASC
  total_DESC
  status_ASC
  status_DESC
}

type OrderPreviousValues {
  _id: ID!
  total: Float!
  status: OrderStatus!
}

enum OrderStatus {
  CART
  PAID
  WISH
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  customer: PersonUpdateOneRequiredInput
  items: ProductUpdateManyInput
  total: Float
  status: OrderStatus
}

input OrderUpdateManyMutationInput {
  total: Float
  status: OrderStatus
}

input OrderWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  customer: PersonWhereInput
  items_some: ProductWhereInput
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  status: OrderStatus
  status_not: OrderStatus
  status_in: [OrderStatus!]
  status_not_in: [OrderStatus!]
  AND: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  _id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Person {
  _id: ID!
  _createdAt: DateTime!
  _updatedAt: DateTime!
  billing: Billing
  connections(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person!]
  contact: Contact
  career: Career
  name: Name!
  password: String!
  profile: Profile
  sessions: [Session!]
  type: PersonType!
  username: String!
}

type PersonConnection {
  pageInfo: PageInfo!
  edges: [PersonEdge]!
  aggregate: AggregatePerson!
}

input PersonCreateInput {
  _id: ID
  billing: BillingCreateOneInput
  connections: PersonCreateManyInput
  contact: ContactCreateOneInput
  career: CareerCreateOneInput
  name: NameCreateOneInput!
  password: String!
  profile: ProfileCreateOneInput
  sessions: SessionCreateManyInput
  type: PersonType
  username: String!
}

input PersonCreateManyInput {
  create: [PersonCreateInput!]
  connect: [PersonWhereUniqueInput!]
}

input PersonCreateOneInput {
  create: PersonCreateInput
  connect: PersonWhereUniqueInput
}

type PersonEdge {
  node: Person!
  cursor: String!
}

enum PersonOrderByInput {
  _id_ASC
  _id_DESC
  _createdAt_ASC
  _createdAt_DESC
  _updatedAt_ASC
  _updatedAt_DESC
  password_ASC
  password_DESC
  type_ASC
  type_DESC
  username_ASC
  username_DESC
}

type PersonPreviousValues {
  _id: ID!
  _createdAt: DateTime!
  _updatedAt: DateTime!
  password: String!
  type: PersonType!
  username: String!
}

input PersonScalarWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _createdAt: DateTime
  _createdAt_not: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_not_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _updatedAt: DateTime
  _updatedAt_not: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_not_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  type: PersonType
  type_not: PersonType
  type_in: [PersonType!]
  type_not_in: [PersonType!]
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  AND: [PersonScalarWhereInput!]
  OR: [PersonScalarWhereInput!]
  NOT: [PersonScalarWhereInput!]
}

type PersonSubscriptionPayload {
  mutation: MutationType!
  node: Person
  updatedFields: [String!]
  previousValues: PersonPreviousValues
}

input PersonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PersonWhereInput
  AND: [PersonSubscriptionWhereInput!]
}

enum PersonType {
  ADMINISTRATOR
  EMPLOYEE
  PARTNER
  USER
  VENDOR
}

input PersonUpdateDataInput {
  billing: BillingUpdateOneInput
  connections: PersonUpdateManyInput
  contact: ContactUpdateOneInput
  career: CareerUpdateOneInput
  name: NameUpdateOneRequiredInput
  password: String
  profile: ProfileUpdateOneInput
  sessions: SessionUpdateManyInput
  type: PersonType
  username: String
}

input PersonUpdateInput {
  billing: BillingUpdateOneInput
  connections: PersonUpdateManyInput
  contact: ContactUpdateOneInput
  career: CareerUpdateOneInput
  name: NameUpdateOneRequiredInput
  password: String
  profile: ProfileUpdateOneInput
  sessions: SessionUpdateManyInput
  type: PersonType
  username: String
}

input PersonUpdateManyDataInput {
  password: String
  type: PersonType
  username: String
}

input PersonUpdateManyInput {
  create: [PersonCreateInput!]
  update: [PersonUpdateWithWhereUniqueNestedInput!]
  upsert: [PersonUpsertWithWhereUniqueNestedInput!]
  delete: [PersonWhereUniqueInput!]
  connect: [PersonWhereUniqueInput!]
  set: [PersonWhereUniqueInput!]
  disconnect: [PersonWhereUniqueInput!]
  deleteMany: [PersonScalarWhereInput!]
  updateMany: [PersonUpdateManyWithWhereNestedInput!]
}

input PersonUpdateManyMutationInput {
  password: String
  type: PersonType
  username: String
}

input PersonUpdateManyWithWhereNestedInput {
  where: PersonScalarWhereInput!
  data: PersonUpdateManyDataInput!
}

input PersonUpdateOneRequiredInput {
  create: PersonCreateInput
  update: PersonUpdateDataInput
  upsert: PersonUpsertNestedInput
  connect: PersonWhereUniqueInput
}

input PersonUpdateWithWhereUniqueNestedInput {
  where: PersonWhereUniqueInput!
  data: PersonUpdateDataInput!
}

input PersonUpsertNestedInput {
  update: PersonUpdateDataInput!
  create: PersonCreateInput!
}

input PersonUpsertWithWhereUniqueNestedInput {
  where: PersonWhereUniqueInput!
  update: PersonUpdateDataInput!
  create: PersonCreateInput!
}

input PersonWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _createdAt: DateTime
  _createdAt_not: DateTime
  _createdAt_in: [DateTime!]
  _createdAt_not_in: [DateTime!]
  _createdAt_lt: DateTime
  _createdAt_lte: DateTime
  _createdAt_gt: DateTime
  _createdAt_gte: DateTime
  _updatedAt: DateTime
  _updatedAt_not: DateTime
  _updatedAt_in: [DateTime!]
  _updatedAt_not_in: [DateTime!]
  _updatedAt_lt: DateTime
  _updatedAt_lte: DateTime
  _updatedAt_gt: DateTime
  _updatedAt_gte: DateTime
  billing: BillingWhereInput
  connections_some: PersonWhereInput
  contact: ContactWhereInput
  career: CareerWhereInput
  name: NameWhereInput
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  profile: ProfileWhereInput
  sessions_some: SessionWhereInput
  sessions_every: SessionRestrictedWhereInput
  sessions_none: SessionRestrictedWhereInput
  type: PersonType
  type_not: PersonType
  type_in: [PersonType!]
  type_not_in: [PersonType!]
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  AND: [PersonWhereInput!]
}

input PersonWhereUniqueInput {
  _id: ID
  username: String
}

type Price {
  list: Float!
  retail: Float!
  savings: Float
  savingsPct: Float
}

input PriceCreateInput {
  list: Float!
  retail: Float!
  savings: Float
  savingsPct: Float
}

input PriceCreateOneInput {
  create: PriceCreateInput
}

input PriceUpdateDataInput {
  list: Float
  retail: Float
  savings: Float
  savingsPct: Float
}

input PriceUpdateOneRequiredInput {
  create: PriceCreateInput
  update: PriceUpdateDataInput
  upsert: PriceUpsertNestedInput
}

input PriceUpsertNestedInput {
  update: PriceUpdateDataInput!
  create: PriceCreateInput!
}

input PriceWhereInput {
  list: Float
  list_not: Float
  list_in: [Float!]
  list_not_in: [Float!]
  list_lt: Float
  list_lte: Float
  list_gt: Float
  list_gte: Float
  retail: Float
  retail_not: Float
  retail_in: [Float!]
  retail_not_in: [Float!]
  retail_lt: Float
  retail_lte: Float
  retail_gt: Float
  retail_gte: Float
  savings: Float
  savings_not: Float
  savings_in: [Float!]
  savings_not_in: [Float!]
  savings_lt: Float
  savings_lte: Float
  savings_gt: Float
  savings_gte: Float
  savingsPct: Float
  savingsPct_not: Float
  savingsPct_in: [Float!]
  savingsPct_not_in: [Float!]
  savingsPct_lt: Float
  savingsPct_lte: Float
  savingsPct_gt: Float
  savingsPct_gte: Float
  AND: [PriceWhereInput!]
}

type Product {
  _id: ID!
  _handlerId: ID!
  name: String!
  category: ProductCategory
  description: String!
  details: Json
  manufacturer: Manufacturer
  price: Price!
  quantity: Int!
  shipping: Shipping
  sku: String
}

enum ProductCategory {
  UNCATEGORIZED
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  _id: ID
  _handlerId: ID
  name: String!
  category: ProductCategory
  description: String!
  details: Json
  manufacturer: ManufacturerCreateOneInput
  price: PriceCreateOneInput!
  quantity: Int
  shipping: ShippingCreateOneInput
  sku: String
}

input ProductCreateManyInput {
  create: [ProductCreateInput!]
  connect: [ProductWhereUniqueInput!]
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  _id_ASC
  _id_DESC
  _handlerId_ASC
  _handlerId_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  description_ASC
  description_DESC
  details_ASC
  details_DESC
  quantity_ASC
  quantity_DESC
  sku_ASC
  sku_DESC
}

type ProductPreviousValues {
  _id: ID!
  _handlerId: ID!
  name: String!
  category: ProductCategory
  description: String!
  details: Json
  quantity: Int!
  sku: String
}

input ProductScalarWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _handlerId: ID
  _handlerId_not: ID
  _handlerId_in: [ID!]
  _handlerId_not_in: [ID!]
  _handlerId_lt: ID
  _handlerId_lte: ID
  _handlerId_gt: ID
  _handlerId_gte: ID
  _handlerId_contains: ID
  _handlerId_not_contains: ID
  _handlerId_starts_with: ID
  _handlerId_not_starts_with: ID
  _handlerId_ends_with: ID
  _handlerId_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: ProductCategory
  category_not: ProductCategory
  category_in: [ProductCategory!]
  category_not_in: [ProductCategory!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  AND: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
  category: ProductCategory
  description: String
  details: Json
  manufacturer: ManufacturerUpdateOneInput
  price: PriceUpdateOneRequiredInput
  quantity: Int
  shipping: ShippingUpdateOneInput
  sku: String
}

input ProductUpdateInput {
  name: String
  category: ProductCategory
  description: String
  details: Json
  manufacturer: ManufacturerUpdateOneInput
  price: PriceUpdateOneRequiredInput
  quantity: Int
  shipping: ShippingUpdateOneInput
  sku: String
}

input ProductUpdateManyDataInput {
  name: String
  category: ProductCategory
  description: String
  details: Json
  quantity: Int
  sku: String
}

input ProductUpdateManyInput {
  create: [ProductCreateInput!]
  update: [ProductUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductUpsertWithWhereUniqueNestedInput!]
  delete: [ProductWhereUniqueInput!]
  connect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  disconnect: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  updateMany: [ProductUpdateManyWithWhereNestedInput!]
}

input ProductUpdateManyMutationInput {
  name: String
  category: ProductCategory
  description: String
  details: Json
  quantity: Int
  sku: String
}

input ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput!
  data: ProductUpdateManyDataInput!
}

input ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  data: ProductUpdateDataInput!
}

input ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput!
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  _id: ID
  _id_not: ID
  _id_in: [ID!]
  _id_not_in: [ID!]
  _id_lt: ID
  _id_lte: ID
  _id_gt: ID
  _id_gte: ID
  _id_contains: ID
  _id_not_contains: ID
  _id_starts_with: ID
  _id_not_starts_with: ID
  _id_ends_with: ID
  _id_not_ends_with: ID
  _handlerId: ID
  _handlerId_not: ID
  _handlerId_in: [ID!]
  _handlerId_not_in: [ID!]
  _handlerId_lt: ID
  _handlerId_lte: ID
  _handlerId_gt: ID
  _handlerId_gte: ID
  _handlerId_contains: ID
  _handlerId_not_contains: ID
  _handlerId_starts_with: ID
  _handlerId_not_starts_with: ID
  _handlerId_ends_with: ID
  _handlerId_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: ProductCategory
  category_not: ProductCategory
  category_in: [ProductCategory!]
  category_not_in: [ProductCategory!]
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  manufacturer: ManufacturerWhereInput
  price: PriceWhereInput
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  shipping: ShippingWhereInput
  sku: String
  sku_not: String
  sku_in: [String!]
  sku_not_in: [String!]
  sku_lt: String
  sku_lte: String
  sku_gt: String
  sku_gte: String
  sku_contains: String
  sku_not_contains: String
  sku_starts_with: String
  sku_not_starts_with: String
  sku_ends_with: String
  sku_not_ends_with: String
  AND: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  _id: ID
  _handlerId: ID
  name: String
}

type Profile {
  avatar: String
  gender: Gender
  headline: String
}

input ProfileCreateInput {
  avatar: String
  gender: Gender
  headline: String
}

input ProfileCreateOneInput {
  create: ProfileCreateInput
}

input ProfileUpdateDataInput {
  avatar: String
  gender: Gender
  headline: String
}

input ProfileUpdateOneInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput!
  create: ProfileCreateInput!
}

input ProfileWhereInput {
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  headline: String
  headline_not: String
  headline_in: [String!]
  headline_not_in: [String!]
  headline_lt: String
  headline_lte: String
  headline_gt: String
  headline_gte: String
  headline_contains: String
  headline_not_contains: String
  headline_starts_with: String
  headline_not_starts_with: String
  headline_ends_with: String
  headline_not_ends_with: String
  AND: [ProfileWhereInput!]
}

type Query {
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  document(where: DocumentWhereUniqueInput!): Document
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document]!
  documentsConnection(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentConnection!
  notification(where: NotificationWhereUniqueInput!): Notification
  notifications(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Notification]!
  notificationsConnection(where: NotificationWhereInput, orderBy: NotificationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NotificationConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  person(where: PersonWhereUniqueInput!): Person
  persons(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person]!
  personsConnection(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  node(id: ID!): Node
}

type ReceivedBy {
  _personId: Person!
  _receivedAt: DateTime!
  _readAt: DateTime!
}

input ReceivedByCreateInput {
  _personId: PersonCreateOneInput!
  _receivedAt: DateTime!
  _readAt: DateTime!
}

input ReceivedByCreateManyInput {
  create: [ReceivedByCreateInput!]
}

input ReceivedByRestrictedWhereInput {
  _receivedAt: DateTime
  _receivedAt_not: DateTime
  _receivedAt_in: [DateTime!]
  _receivedAt_not_in: [DateTime!]
  _receivedAt_lt: DateTime
  _receivedAt_lte: DateTime
  _receivedAt_gt: DateTime
  _receivedAt_gte: DateTime
  _readAt: DateTime
  _readAt_not: DateTime
  _readAt_in: [DateTime!]
  _readAt_not_in: [DateTime!]
  _readAt_lt: DateTime
  _readAt_lte: DateTime
  _readAt_gt: DateTime
  _readAt_gte: DateTime
  AND: [ReceivedByRestrictedWhereInput!]
}

input ReceivedByScalarWhereInput {
  _receivedAt: DateTime
  _receivedAt_not: DateTime
  _receivedAt_in: [DateTime!]
  _receivedAt_not_in: [DateTime!]
  _receivedAt_lt: DateTime
  _receivedAt_lte: DateTime
  _receivedAt_gt: DateTime
  _receivedAt_gte: DateTime
  _readAt: DateTime
  _readAt_not: DateTime
  _readAt_in: [DateTime!]
  _readAt_not_in: [DateTime!]
  _readAt_lt: DateTime
  _readAt_lte: DateTime
  _readAt_gt: DateTime
  _readAt_gte: DateTime
  AND: [ReceivedByScalarWhereInput!]
  OR: [ReceivedByScalarWhereInput!]
  NOT: [ReceivedByScalarWhereInput!]
}

input ReceivedByUpdateManyDataInput {
  _receivedAt: DateTime
  _readAt: DateTime
}

input ReceivedByUpdateManyInput {
  create: [ReceivedByCreateInput!]
  deleteMany: [ReceivedByScalarWhereInput!]
  updateMany: [ReceivedByUpdateManyWithWhereNestedInput!]
}

input ReceivedByUpdateManyWithWhereNestedInput {
  where: ReceivedByScalarWhereInput!
  data: ReceivedByUpdateManyDataInput!
}

input ReceivedByWhereInput {
  _personId: PersonWhereInput
  _receivedAt: DateTime
  _receivedAt_not: DateTime
  _receivedAt_in: [DateTime!]
  _receivedAt_not_in: [DateTime!]
  _receivedAt_lt: DateTime
  _receivedAt_lte: DateTime
  _receivedAt_gt: DateTime
  _receivedAt_gte: DateTime
  _readAt: DateTime
  _readAt_not: DateTime
  _readAt_in: [DateTime!]
  _readAt_not_in: [DateTime!]
  _readAt_lt: DateTime
  _readAt_lte: DateTime
  _readAt_gt: DateTime
  _readAt_gte: DateTime
  AND: [ReceivedByWhereInput!]
}

type Sender {
  _personId: Person!
  name: String!
  type: SenderType!
}

input SenderCreateInput {
  _personId: PersonCreateOneInput!
  name: String!
  type: SenderType!
}

input SenderCreateOneInput {
  create: SenderCreateInput
}

enum SenderType {
  SYSTEM
  PERSON
}

input SenderUpdateDataInput {
  _personId: PersonUpdateOneRequiredInput
  name: String
  type: SenderType
}

input SenderUpdateOneRequiredInput {
  create: SenderCreateInput
  update: SenderUpdateDataInput
  upsert: SenderUpsertNestedInput
}

input SenderUpsertNestedInput {
  update: SenderUpdateDataInput!
  create: SenderCreateInput!
}

input SenderWhereInput {
  _personId: PersonWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  type: SenderType
  type_not: SenderType
  type_in: [SenderType!]
  type_not_in: [SenderType!]
  AND: [SenderWhereInput!]
}

type Session {
  device: String
  location: String
  token: String
}

input SessionCreateInput {
  device: String
  location: String
  token: String
}

input SessionCreateManyInput {
  create: [SessionCreateInput!]
}

input SessionRestrictedWhereInput {
  device: String
  device_not: String
  device_in: [String!]
  device_not_in: [String!]
  device_lt: String
  device_lte: String
  device_gt: String
  device_gte: String
  device_contains: String
  device_not_contains: String
  device_starts_with: String
  device_not_starts_with: String
  device_ends_with: String
  device_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  AND: [SessionRestrictedWhereInput!]
}

input SessionScalarWhereInput {
  device: String
  device_not: String
  device_in: [String!]
  device_not_in: [String!]
  device_lt: String
  device_lte: String
  device_gt: String
  device_gte: String
  device_contains: String
  device_not_contains: String
  device_starts_with: String
  device_not_starts_with: String
  device_ends_with: String
  device_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  AND: [SessionScalarWhereInput!]
  OR: [SessionScalarWhereInput!]
  NOT: [SessionScalarWhereInput!]
}

input SessionUpdateManyDataInput {
  device: String
  location: String
  token: String
}

input SessionUpdateManyInput {
  create: [SessionCreateInput!]
  deleteMany: [SessionScalarWhereInput!]
  updateMany: [SessionUpdateManyWithWhereNestedInput!]
}

input SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput!
  data: SessionUpdateManyDataInput!
}

input SessionWhereInput {
  device: String
  device_not: String
  device_in: [String!]
  device_not_in: [String!]
  device_lt: String
  device_lte: String
  device_gt: String
  device_gte: String
  device_contains: String
  device_not_contains: String
  device_starts_with: String
  device_not_starts_with: String
  device_ends_with: String
  device_not_ends_with: String
  location: String
  location_not: String
  location_in: [String!]
  location_not_in: [String!]
  location_lt: String
  location_lte: String
  location_gt: String
  location_gte: String
  location_contains: String
  location_not_contains: String
  location_starts_with: String
  location_not_starts_with: String
  location_ends_with: String
  location_not_ends_with: String
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  AND: [SessionWhereInput!]
}

type Shipping {
  depth: Float!
  height: Float!
  scale: DimensionScale!
  weight: Float!
  width: Float!
}

input ShippingCreateInput {
  depth: Float!
  height: Float!
  scale: DimensionScale
  weight: Float!
  width: Float!
}

input ShippingCreateOneInput {
  create: ShippingCreateInput
}

input ShippingUpdateDataInput {
  depth: Float
  height: Float
  scale: DimensionScale
  weight: Float
  width: Float
}

input ShippingUpdateOneInput {
  create: ShippingCreateInput
  update: ShippingUpdateDataInput
  upsert: ShippingUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input ShippingUpsertNestedInput {
  update: ShippingUpdateDataInput!
  create: ShippingCreateInput!
}

input ShippingWhereInput {
  depth: Float
  depth_not: Float
  depth_in: [Float!]
  depth_not_in: [Float!]
  depth_lt: Float
  depth_lte: Float
  depth_gt: Float
  depth_gte: Float
  height: Float
  height_not: Float
  height_in: [Float!]
  height_not_in: [Float!]
  height_lt: Float
  height_lte: Float
  height_gt: Float
  height_gte: Float
  scale: DimensionScale
  scale_not: DimensionScale
  scale_in: [DimensionScale!]
  scale_not_in: [DimensionScale!]
  weight: Float
  weight_not: Float
  weight_in: [Float!]
  weight_not_in: [Float!]
  weight_lt: Float
  weight_lte: Float
  weight_gt: Float
  weight_gte: Float
  width: Float
  width_not: Float
  width_in: [Float!]
  width_not_in: [Float!]
  width_lt: Float
  width_lte: Float
  width_gt: Float
  width_gte: Float
  AND: [ShippingWhereInput!]
}

type Subscription {
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  document(where: DocumentSubscriptionWhereInput): DocumentSubscriptionPayload
  notification(where: NotificationSubscriptionWhereInput): NotificationSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  person(where: PersonSubscriptionWhereInput): PersonSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
}
`