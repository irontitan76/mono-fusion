// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  document: (where?: DocumentWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  document: (where: DocumentWhereUniqueInput) => DocumentNullablePromise;
  documents: (args?: {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Document>;
  documentsConnection: (args?: {
    where?: DocumentWhereInput;
    orderBy?: DocumentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DocumentConnectionPromise;
  notification: (
    where: NotificationWhereUniqueInput
  ) => NotificationNullablePromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonNullablePromise;
  persons: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Person>;
  personsConnection: (args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PersonConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createDocument: (data: DocumentCreateInput) => DocumentPromise;
  updateDocument: (args: {
    data: DocumentUpdateInput;
    where: DocumentWhereUniqueInput;
  }) => DocumentPromise;
  updateManyDocuments: (args: {
    data: DocumentUpdateManyMutationInput;
    where?: DocumentWhereInput;
  }) => BatchPayloadPromise;
  upsertDocument: (args: {
    where: DocumentWhereUniqueInput;
    create: DocumentCreateInput;
    update: DocumentUpdateInput;
  }) => DocumentPromise;
  deleteDocument: (where: DocumentWhereUniqueInput) => DocumentPromise;
  deleteManyDocuments: (where?: DocumentWhereInput) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (args: {
    data: PersonUpdateInput;
    where: PersonWhereUniqueInput;
  }) => PersonPromise;
  updateManyPersons: (args: {
    data: PersonUpdateManyMutationInput;
    where?: PersonWhereInput;
  }) => BatchPayloadPromise;
  upsertPerson: (args: {
    where: PersonWhereUniqueInput;
    create: PersonCreateInput;
    update: PersonUpdateInput;
  }) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  document: (
    where?: DocumentSubscriptionWhereInput
  ) => DocumentSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AccountType = "CHECKING" | "SAVINGS";

export type Gender = "MALE" | "FEMALE" | "OTHER";

export type SenderType = "SYSTEM" | "PERSON";

export type OrderOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "status_ASC"
  | "status_DESC";

export type CardType = "CREDIT" | "DEBIT";

export type ProductOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "_handlerId_ASC"
  | "_handlerId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "description_ASC"
  | "description_DESC"
  | "details_ASC"
  | "details_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "sku_ASC"
  | "sku_DESC";

export type DocumentOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "_createdAt_ASC"
  | "_createdAt_DESC"
  | "_publishedAt_ASC"
  | "_publishedAt_DESC"
  | "_updatedAt_ASC"
  | "_updatedAt_DESC"
  | "category_ASC"
  | "category_DESC"
  | "content_ASC"
  | "content_DESC"
  | "subtitle_ASC"
  | "subtitle_DESC"
  | "title_ASC"
  | "title_DESC";

export type ProductCategory = "UNCATEGORIZED";

export type PersonOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "_createdAt_ASC"
  | "_createdAt_DESC"
  | "_updatedAt_ASC"
  | "_updatedAt_DESC"
  | "password_ASC"
  | "password_DESC"
  | "username_ASC"
  | "username_DESC";

export type CommentType = "CONVERSATION" | "REVIEW";

export type CommentOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "_createdAt_ASC"
  | "_createdAt_DESC"
  | "_discussionId_ASC"
  | "_discussionId_DESC"
  | "_updatedAt_ASC"
  | "_updatedAt_DESC"
  | "content_ASC"
  | "content_DESC"
  | "fullSlug_ASC"
  | "fullSlug_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "type_ASC"
  | "type_DESC";

export type DocumentCategory = "UNCATEGORIZED" | "CORPORATE";

export type NotificationOrderByInput =
  | "_id_ASC"
  | "_id_DESC"
  | "_createdAt_ASC"
  | "_createdAt_DESC"
  | "_sentAt_ASC"
  | "_sentAt_DESC"
  | "message_ASC"
  | "message_DESC"
  | "title_ASC"
  | "title_DESC";

export type DimensionScale = "FOOT" | "METER";

export type OrderStatus = "CART" | "PAID" | "WISH";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CommentUpdateInput {
  _authorId?: Maybe<PersonUpdateOneRequiredInput>;
  _discussionId?: Maybe<ID_Input>;
  _parentId?: Maybe<CommentUpdateOneInput>;
  content?: Maybe<String>;
  fullSlug?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<CommentType>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
  fullSlug?: Maybe<String>;
}>;

export interface CardUpdateManyInput {
  create?: Maybe<CardCreateInput[] | CardCreateInput>;
  deleteMany?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  updateMany?: Maybe<
    CardUpdateManyWithWhereNestedInput[] | CardUpdateManyWithWhereNestedInput
  >;
}

export interface ContactWhereInput {
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  postalCode?: Maybe<String>;
  postalCode_not?: Maybe<String>;
  postalCode_in?: Maybe<String[] | String>;
  postalCode_not_in?: Maybe<String[] | String>;
  postalCode_lt?: Maybe<String>;
  postalCode_lte?: Maybe<String>;
  postalCode_gt?: Maybe<String>;
  postalCode_gte?: Maybe<String>;
  postalCode_contains?: Maybe<String>;
  postalCode_not_contains?: Maybe<String>;
  postalCode_starts_with?: Maybe<String>;
  postalCode_not_starts_with?: Maybe<String>;
  postalCode_ends_with?: Maybe<String>;
  postalCode_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface CardScalarWhereInput {
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  cvv?: Maybe<Int>;
  cvv_not?: Maybe<Int>;
  cvv_in?: Maybe<Int[] | Int>;
  cvv_not_in?: Maybe<Int[] | Int>;
  cvv_lt?: Maybe<Int>;
  cvv_lte?: Maybe<Int>;
  cvv_gt?: Maybe<Int>;
  cvv_gte?: Maybe<Int>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  type?: Maybe<CardType>;
  type_not?: Maybe<CardType>;
  type_in?: Maybe<CardType[] | CardType>;
  type_not_in?: Maybe<CardType[] | CardType>;
  AND?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  OR?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
  NOT?: Maybe<CardScalarWhereInput[] | CardScalarWhereInput>;
}

export interface ExperienceWhereInput {
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  start?: Maybe<DateTimeInput>;
  start_not?: Maybe<DateTimeInput>;
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_lt?: Maybe<DateTimeInput>;
  start_lte?: Maybe<DateTimeInput>;
  start_gt?: Maybe<DateTimeInput>;
  start_gte?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  end_not?: Maybe<DateTimeInput>;
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_lt?: Maybe<DateTimeInput>;
  end_lte?: Maybe<DateTimeInput>;
  end_gt?: Maybe<DateTimeInput>;
  end_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ExperienceWhereInput[] | ExperienceWhereInput>;
}

export interface CardUpdateManyWithWhereNestedInput {
  where: CardScalarWhereInput;
  data: CardUpdateManyDataInput;
}

export interface ProfileWhereInput {
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  headline?: Maybe<String>;
  headline_not?: Maybe<String>;
  headline_in?: Maybe<String[] | String>;
  headline_not_in?: Maybe<String[] | String>;
  headline_lt?: Maybe<String>;
  headline_lte?: Maybe<String>;
  headline_gt?: Maybe<String>;
  headline_gte?: Maybe<String>;
  headline_contains?: Maybe<String>;
  headline_not_contains?: Maybe<String>;
  headline_starts_with?: Maybe<String>;
  headline_not_starts_with?: Maybe<String>;
  headline_ends_with?: Maybe<String>;
  headline_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
}

export interface CardUpdateManyDataInput {
  name?: Maybe<String>;
  number?: Maybe<Int>;
  cvv?: Maybe<Int>;
  expiration?: Maybe<DateTimeInput>;
  type?: Maybe<CardType>;
}

export interface SessionWhereInput {
  device?: Maybe<String>;
  device_not?: Maybe<String>;
  device_in?: Maybe<String[] | String>;
  device_not_in?: Maybe<String[] | String>;
  device_lt?: Maybe<String>;
  device_lte?: Maybe<String>;
  device_gt?: Maybe<String>;
  device_gte?: Maybe<String>;
  device_contains?: Maybe<String>;
  device_not_contains?: Maybe<String>;
  device_starts_with?: Maybe<String>;
  device_not_starts_with?: Maybe<String>;
  device_ends_with?: Maybe<String>;
  device_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  AND?: Maybe<SessionWhereInput[] | SessionWhereInput>;
}

export interface BillingUpsertNestedInput {
  update: BillingUpdateDataInput;
  create: BillingCreateInput;
}

export interface CardWhereInput {
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  cvv?: Maybe<Int>;
  cvv_not?: Maybe<Int>;
  cvv_in?: Maybe<Int[] | Int>;
  cvv_not_in?: Maybe<Int[] | Int>;
  cvv_lt?: Maybe<Int>;
  cvv_lte?: Maybe<Int>;
  cvv_gt?: Maybe<Int>;
  cvv_gte?: Maybe<Int>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  type?: Maybe<CardType>;
  type_not?: Maybe<CardType>;
  type_in?: Maybe<CardType[] | CardType>;
  type_not_in?: Maybe<CardType[] | CardType>;
  AND?: Maybe<CardWhereInput[] | CardWhereInput>;
}

export interface ContactCreateOneInput {
  create?: Maybe<ContactCreateInput>;
}

export interface NotificationUpdateInput {
  _sentAt?: Maybe<DateTimeInput>;
  receiver?: Maybe<NotificationUpdatereceiverInput>;
  message?: Maybe<String>;
  receivedBy?: Maybe<ReceivedByUpdateManyInput>;
  sender?: Maybe<SenderUpdateOneRequiredInput>;
  title?: Maybe<String>;
}

export interface ContactCreateInput {
  emails?: Maybe<ContactCreateemailsInput>;
  address1: String;
  address2: String;
  city: String;
  state: String;
  country: String;
  postalCode: String;
  phones?: Maybe<ContactCreatephonesInput>;
}

export interface PersonUpdateManyInput {
  create?: Maybe<PersonCreateInput[] | PersonCreateInput>;
  update?: Maybe<
    | PersonUpdateWithWhereUniqueNestedInput[]
    | PersonUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PersonUpsertWithWhereUniqueNestedInput[]
    | PersonUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PersonWhereUniqueInput[] | PersonWhereUniqueInput>;
  connect?: Maybe<PersonWhereUniqueInput[] | PersonWhereUniqueInput>;
  set?: Maybe<PersonWhereUniqueInput[] | PersonWhereUniqueInput>;
  disconnect?: Maybe<PersonWhereUniqueInput[] | PersonWhereUniqueInput>;
  deleteMany?: Maybe<PersonScalarWhereInput[] | PersonScalarWhereInput>;
  updateMany?: Maybe<
    | PersonUpdateManyWithWhereNestedInput[]
    | PersonUpdateManyWithWhereNestedInput
  >;
}

export interface ContactCreateemailsInput {
  set?: Maybe<String[] | String>;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PersonWhereInput>;
  AND?: Maybe<PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput>;
}

export interface ContactCreatephonesInput {
  set?: Maybe<String[] | String>;
}

export interface AccountRestrictedWhereInput {
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  routing?: Maybe<Int>;
  routing_not?: Maybe<Int>;
  routing_in?: Maybe<Int[] | Int>;
  routing_not_in?: Maybe<Int[] | Int>;
  routing_lt?: Maybe<Int>;
  routing_lte?: Maybe<Int>;
  routing_gt?: Maybe<Int>;
  routing_gte?: Maybe<Int>;
  type?: Maybe<AccountType>;
  type_not?: Maybe<AccountType>;
  type_in?: Maybe<AccountType[] | AccountType>;
  type_not_in?: Maybe<AccountType[] | AccountType>;
  AND?: Maybe<AccountRestrictedWhereInput[] | AccountRestrictedWhereInput>;
}

export interface CareerCreateOneInput {
  create?: Maybe<CareerCreateInput>;
}

export interface AccountWhereInput {
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  routing?: Maybe<Int>;
  routing_not?: Maybe<Int>;
  routing_in?: Maybe<Int[] | Int>;
  routing_not_in?: Maybe<Int[] | Int>;
  routing_lt?: Maybe<Int>;
  routing_lte?: Maybe<Int>;
  routing_gt?: Maybe<Int>;
  routing_gte?: Maybe<Int>;
  type?: Maybe<AccountType>;
  type_not?: Maybe<AccountType>;
  type_in?: Maybe<AccountType[] | AccountType>;
  type_not_in?: Maybe<AccountType[] | AccountType>;
  AND?: Maybe<AccountWhereInput[] | AccountWhereInput>;
}

export interface CareerCreateInput {
  company: String;
  experience?: Maybe<ExperienceCreateOneInput>;
  position: String;
}

export interface DocumentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DocumentWhereInput>;
  AND?: Maybe<
    DocumentSubscriptionWhereInput[] | DocumentSubscriptionWhereInput
  >;
}

export interface ExperienceCreateOneInput {
  create?: Maybe<ExperienceCreateInput>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  category?: Maybe<ProductCategory>;
  description?: Maybe<String>;
  details?: Maybe<Json>;
  quantity?: Maybe<Int>;
  sku?: Maybe<String>;
}

export interface ExperienceCreateInput {
  company: String;
  position: String;
  description?: Maybe<String>;
  start: DateTimeInput;
  end: DateTimeInput;
}

export type DocumentWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
  title?: Maybe<String>;
}>;

export interface NameCreateOneInput {
  create?: Maybe<NameCreateInput>;
}

export interface BillingWhereInput {
  accounts_some?: Maybe<AccountWhereInput>;
  accounts_every?: Maybe<AccountRestrictedWhereInput>;
  accounts_none?: Maybe<AccountRestrictedWhereInput>;
  cards_some?: Maybe<CardWhereInput>;
  cards_every?: Maybe<CardRestrictedWhereInput>;
  cards_none?: Maybe<CardRestrictedWhereInput>;
  AND?: Maybe<BillingWhereInput[] | BillingWhereInput>;
}

export interface NameCreateInput {
  first: String;
  last: String;
  middle?: Maybe<String>;
  preferred?: Maybe<String>;
}

export interface PersonWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _createdAt?: Maybe<DateTimeInput>;
  _createdAt_not?: Maybe<DateTimeInput>;
  _createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_lt?: Maybe<DateTimeInput>;
  _createdAt_lte?: Maybe<DateTimeInput>;
  _createdAt_gt?: Maybe<DateTimeInput>;
  _createdAt_gte?: Maybe<DateTimeInput>;
  _updatedAt?: Maybe<DateTimeInput>;
  _updatedAt_not?: Maybe<DateTimeInput>;
  _updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_lt?: Maybe<DateTimeInput>;
  _updatedAt_lte?: Maybe<DateTimeInput>;
  _updatedAt_gt?: Maybe<DateTimeInput>;
  _updatedAt_gte?: Maybe<DateTimeInput>;
  billing?: Maybe<BillingWhereInput>;
  connections_some?: Maybe<PersonWhereInput>;
  contact?: Maybe<ContactWhereInput>;
  career?: Maybe<CareerWhereInput>;
  name?: Maybe<NameWhereInput>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profile?: Maybe<ProfileWhereInput>;
  sessions_some?: Maybe<SessionWhereInput>;
  sessions_every?: Maybe<SessionRestrictedWhereInput>;
  sessions_none?: Maybe<SessionRestrictedWhereInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  AND?: Maybe<PersonWhereInput[] | PersonWhereInput>;
}

export interface ProfileCreateOneInput {
  create?: Maybe<ProfileCreateInput>;
}

export interface OrderUpdateManyMutationInput {
  total?: Maybe<Float>;
  status?: Maybe<OrderStatus>;
}

export interface ProfileCreateInput {
  avatar?: Maybe<String>;
  gender?: Maybe<Gender>;
  headline?: Maybe<String>;
}

export type NotificationWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
}>;

export interface SessionCreateManyInput {
  create?: Maybe<SessionCreateInput[] | SessionCreateInput>;
}

export interface ProductScalarWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _handlerId?: Maybe<ID_Input>;
  _handlerId_not?: Maybe<ID_Input>;
  _handlerId_in?: Maybe<ID_Input[] | ID_Input>;
  _handlerId_not_in?: Maybe<ID_Input[] | ID_Input>;
  _handlerId_lt?: Maybe<ID_Input>;
  _handlerId_lte?: Maybe<ID_Input>;
  _handlerId_gt?: Maybe<ID_Input>;
  _handlerId_gte?: Maybe<ID_Input>;
  _handlerId_contains?: Maybe<ID_Input>;
  _handlerId_not_contains?: Maybe<ID_Input>;
  _handlerId_starts_with?: Maybe<ID_Input>;
  _handlerId_not_starts_with?: Maybe<ID_Input>;
  _handlerId_ends_with?: Maybe<ID_Input>;
  _handlerId_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<ProductCategory>;
  category_not?: Maybe<ProductCategory>;
  category_in?: Maybe<ProductCategory[] | ProductCategory>;
  category_not_in?: Maybe<ProductCategory[] | ProductCategory>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export interface SessionCreateInput {
  device?: Maybe<String>;
  location?: Maybe<String>;
  token?: Maybe<String>;
}

export interface ShippingUpsertNestedInput {
  update: ShippingUpdateDataInput;
  create: ShippingCreateInput;
}

export interface CommentCreateOneInput {
  create?: Maybe<CommentCreateInput>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface ReceivedByWhereInput {
  _personId?: Maybe<PersonWhereInput>;
  _receivedAt?: Maybe<DateTimeInput>;
  _receivedAt_not?: Maybe<DateTimeInput>;
  _receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _receivedAt_lt?: Maybe<DateTimeInput>;
  _receivedAt_lte?: Maybe<DateTimeInput>;
  _receivedAt_gt?: Maybe<DateTimeInput>;
  _receivedAt_gte?: Maybe<DateTimeInput>;
  _readAt?: Maybe<DateTimeInput>;
  _readAt_not?: Maybe<DateTimeInput>;
  _readAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _readAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _readAt_lt?: Maybe<DateTimeInput>;
  _readAt_lte?: Maybe<DateTimeInput>;
  _readAt_gt?: Maybe<DateTimeInput>;
  _readAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReceivedByWhereInput[] | ReceivedByWhereInput>;
}

export interface ReceivedByUpdateManyDataInput {
  _receivedAt?: Maybe<DateTimeInput>;
  _readAt?: Maybe<DateTimeInput>;
}

export interface SenderWhereInput {
  _personId?: Maybe<PersonWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<SenderType>;
  type_not?: Maybe<SenderType>;
  type_in?: Maybe<SenderType[] | SenderType>;
  type_not_in?: Maybe<SenderType[] | SenderType>;
  AND?: Maybe<SenderWhereInput[] | SenderWhereInput>;
}

export interface PersonUpdateOneRequiredInput {
  create?: Maybe<PersonCreateInput>;
  update?: Maybe<PersonUpdateDataInput>;
  upsert?: Maybe<PersonUpsertNestedInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface ShippingUpdateOneInput {
  create?: Maybe<ShippingCreateInput>;
  update?: Maybe<ShippingUpdateDataInput>;
  upsert?: Maybe<ShippingUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface PersonUpdateDataInput {
  billing?: Maybe<BillingUpdateOneInput>;
  connections?: Maybe<PersonUpdateManyInput>;
  contact?: Maybe<ContactUpdateOneInput>;
  career?: Maybe<CareerUpdateOneInput>;
  name?: Maybe<NameUpdateOneRequiredInput>;
  password?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneInput>;
  sessions?: Maybe<SessionUpdateManyInput>;
  username?: Maybe<String>;
}

export interface PriceUpdateDataInput {
  list?: Maybe<Float>;
  retail?: Maybe<Float>;
  savings?: Maybe<Float>;
  savingsPct?: Maybe<Float>;
}

export interface BillingUpdateOneInput {
  create?: Maybe<BillingCreateInput>;
  update?: Maybe<BillingUpdateDataInput>;
  upsert?: Maybe<BillingUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface PriceUpdateOneRequiredInput {
  create?: Maybe<PriceCreateInput>;
  update?: Maybe<PriceUpdateDataInput>;
  upsert?: Maybe<PriceUpsertNestedInput>;
}

export interface BillingUpdateDataInput {
  accounts?: Maybe<AccountUpdateManyInput>;
  cards?: Maybe<CardUpdateManyInput>;
}

export interface ManufacturerUpsertNestedInput {
  update: ManufacturerUpdateDataInput;
  create: ManufacturerCreateInput;
}

export interface AccountUpdateManyInput {
  create?: Maybe<AccountCreateInput[] | AccountCreateInput>;
  deleteMany?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  updateMany?: Maybe<
    | AccountUpdateManyWithWhereNestedInput[]
    | AccountUpdateManyWithWhereNestedInput
  >;
}

export interface PriceWhereInput {
  list?: Maybe<Float>;
  list_not?: Maybe<Float>;
  list_in?: Maybe<Float[] | Float>;
  list_not_in?: Maybe<Float[] | Float>;
  list_lt?: Maybe<Float>;
  list_lte?: Maybe<Float>;
  list_gt?: Maybe<Float>;
  list_gte?: Maybe<Float>;
  retail?: Maybe<Float>;
  retail_not?: Maybe<Float>;
  retail_in?: Maybe<Float[] | Float>;
  retail_not_in?: Maybe<Float[] | Float>;
  retail_lt?: Maybe<Float>;
  retail_lte?: Maybe<Float>;
  retail_gt?: Maybe<Float>;
  retail_gte?: Maybe<Float>;
  savings?: Maybe<Float>;
  savings_not?: Maybe<Float>;
  savings_in?: Maybe<Float[] | Float>;
  savings_not_in?: Maybe<Float[] | Float>;
  savings_lt?: Maybe<Float>;
  savings_lte?: Maybe<Float>;
  savings_gt?: Maybe<Float>;
  savings_gte?: Maybe<Float>;
  savingsPct?: Maybe<Float>;
  savingsPct_not?: Maybe<Float>;
  savingsPct_in?: Maybe<Float[] | Float>;
  savingsPct_not_in?: Maybe<Float[] | Float>;
  savingsPct_lt?: Maybe<Float>;
  savingsPct_lte?: Maybe<Float>;
  savingsPct_gt?: Maybe<Float>;
  savingsPct_gte?: Maybe<Float>;
  AND?: Maybe<PriceWhereInput[] | PriceWhereInput>;
}

export interface AccountScalarWhereInput {
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  routing?: Maybe<Int>;
  routing_not?: Maybe<Int>;
  routing_in?: Maybe<Int[] | Int>;
  routing_not_in?: Maybe<Int[] | Int>;
  routing_lt?: Maybe<Int>;
  routing_lte?: Maybe<Int>;
  routing_gt?: Maybe<Int>;
  routing_gte?: Maybe<Int>;
  type?: Maybe<AccountType>;
  type_not?: Maybe<AccountType>;
  type_in?: Maybe<AccountType[] | AccountType>;
  type_not_in?: Maybe<AccountType[] | AccountType>;
  AND?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  OR?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
  NOT?: Maybe<AccountScalarWhereInput[] | AccountScalarWhereInput>;
}

export interface ShippingWhereInput {
  depth?: Maybe<Float>;
  depth_not?: Maybe<Float>;
  depth_in?: Maybe<Float[] | Float>;
  depth_not_in?: Maybe<Float[] | Float>;
  depth_lt?: Maybe<Float>;
  depth_lte?: Maybe<Float>;
  depth_gt?: Maybe<Float>;
  depth_gte?: Maybe<Float>;
  height?: Maybe<Float>;
  height_not?: Maybe<Float>;
  height_in?: Maybe<Float[] | Float>;
  height_not_in?: Maybe<Float[] | Float>;
  height_lt?: Maybe<Float>;
  height_lte?: Maybe<Float>;
  height_gt?: Maybe<Float>;
  height_gte?: Maybe<Float>;
  scale?: Maybe<DimensionScale>;
  scale_not?: Maybe<DimensionScale>;
  scale_in?: Maybe<DimensionScale[] | DimensionScale>;
  scale_not_in?: Maybe<DimensionScale[] | DimensionScale>;
  weight?: Maybe<Float>;
  weight_not?: Maybe<Float>;
  weight_in?: Maybe<Float[] | Float>;
  weight_not_in?: Maybe<Float[] | Float>;
  weight_lt?: Maybe<Float>;
  weight_lte?: Maybe<Float>;
  weight_gt?: Maybe<Float>;
  weight_gte?: Maybe<Float>;
  width?: Maybe<Float>;
  width_not?: Maybe<Float>;
  width_in?: Maybe<Float[] | Float>;
  width_not_in?: Maybe<Float[] | Float>;
  width_lt?: Maybe<Float>;
  width_lte?: Maybe<Float>;
  width_gt?: Maybe<Float>;
  width_gte?: Maybe<Float>;
  AND?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
}

export interface AccountUpdateManyWithWhereNestedInput {
  where: AccountScalarWhereInput;
  data: AccountUpdateManyDataInput;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  category?: Maybe<ProductCategory>;
  description?: Maybe<String>;
  details?: Maybe<Json>;
  manufacturer?: Maybe<ManufacturerUpdateOneInput>;
  price?: Maybe<PriceUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
  shipping?: Maybe<ShippingUpdateOneInput>;
  sku?: Maybe<String>;
}

export interface AccountUpdateManyDataInput {
  number?: Maybe<Int>;
  routing?: Maybe<Int>;
  type?: Maybe<AccountType>;
}

export interface ProductUpdateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface CareerWhereInput {
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  experience?: Maybe<ExperienceWhereInput>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<CareerWhereInput[] | CareerWhereInput>;
}

export interface ShippingCreateInput {
  depth: Float;
  height: Float;
  scale?: Maybe<DimensionScale>;
  weight: Float;
  width: Float;
}

export interface NameWhereInput {
  first?: Maybe<String>;
  first_not?: Maybe<String>;
  first_in?: Maybe<String[] | String>;
  first_not_in?: Maybe<String[] | String>;
  first_lt?: Maybe<String>;
  first_lte?: Maybe<String>;
  first_gt?: Maybe<String>;
  first_gte?: Maybe<String>;
  first_contains?: Maybe<String>;
  first_not_contains?: Maybe<String>;
  first_starts_with?: Maybe<String>;
  first_not_starts_with?: Maybe<String>;
  first_ends_with?: Maybe<String>;
  first_not_ends_with?: Maybe<String>;
  last?: Maybe<String>;
  last_not?: Maybe<String>;
  last_in?: Maybe<String[] | String>;
  last_not_in?: Maybe<String[] | String>;
  last_lt?: Maybe<String>;
  last_lte?: Maybe<String>;
  last_gt?: Maybe<String>;
  last_gte?: Maybe<String>;
  last_contains?: Maybe<String>;
  last_not_contains?: Maybe<String>;
  last_starts_with?: Maybe<String>;
  last_not_starts_with?: Maybe<String>;
  last_ends_with?: Maybe<String>;
  last_not_ends_with?: Maybe<String>;
  middle?: Maybe<String>;
  middle_not?: Maybe<String>;
  middle_in?: Maybe<String[] | String>;
  middle_not_in?: Maybe<String[] | String>;
  middle_lt?: Maybe<String>;
  middle_lte?: Maybe<String>;
  middle_gt?: Maybe<String>;
  middle_gte?: Maybe<String>;
  middle_contains?: Maybe<String>;
  middle_not_contains?: Maybe<String>;
  middle_starts_with?: Maybe<String>;
  middle_not_starts_with?: Maybe<String>;
  middle_ends_with?: Maybe<String>;
  middle_not_ends_with?: Maybe<String>;
  preferred?: Maybe<String>;
  preferred_not?: Maybe<String>;
  preferred_in?: Maybe<String[] | String>;
  preferred_not_in?: Maybe<String[] | String>;
  preferred_lt?: Maybe<String>;
  preferred_lte?: Maybe<String>;
  preferred_gt?: Maybe<String>;
  preferred_gte?: Maybe<String>;
  preferred_contains?: Maybe<String>;
  preferred_not_contains?: Maybe<String>;
  preferred_starts_with?: Maybe<String>;
  preferred_not_starts_with?: Maybe<String>;
  preferred_ends_with?: Maybe<String>;
  preferred_not_ends_with?: Maybe<String>;
  AND?: Maybe<NameWhereInput[] | NameWhereInput>;
}

export interface PriceCreateInput {
  list: Float;
  retail: Float;
  savings?: Maybe<Float>;
  savingsPct?: Maybe<Float>;
}

export interface CardRestrictedWhereInput {
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  cvv?: Maybe<Int>;
  cvv_not?: Maybe<Int>;
  cvv_in?: Maybe<Int[] | Int>;
  cvv_not_in?: Maybe<Int[] | Int>;
  cvv_lt?: Maybe<Int>;
  cvv_lte?: Maybe<Int>;
  cvv_gt?: Maybe<Int>;
  cvv_gte?: Maybe<Int>;
  expiration?: Maybe<DateTimeInput>;
  expiration_not?: Maybe<DateTimeInput>;
  expiration_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  expiration_lt?: Maybe<DateTimeInput>;
  expiration_lte?: Maybe<DateTimeInput>;
  expiration_gt?: Maybe<DateTimeInput>;
  expiration_gte?: Maybe<DateTimeInput>;
  type?: Maybe<CardType>;
  type_not?: Maybe<CardType>;
  type_in?: Maybe<CardType[] | CardType>;
  type_not_in?: Maybe<CardType[] | CardType>;
  AND?: Maybe<CardRestrictedWhereInput[] | CardRestrictedWhereInput>;
}

export interface PriceCreateOneInput {
  create?: Maybe<PriceCreateInput>;
}

export interface SessionRestrictedWhereInput {
  device?: Maybe<String>;
  device_not?: Maybe<String>;
  device_in?: Maybe<String[] | String>;
  device_not_in?: Maybe<String[] | String>;
  device_lt?: Maybe<String>;
  device_lte?: Maybe<String>;
  device_gt?: Maybe<String>;
  device_gte?: Maybe<String>;
  device_contains?: Maybe<String>;
  device_not_contains?: Maybe<String>;
  device_starts_with?: Maybe<String>;
  device_not_starts_with?: Maybe<String>;
  device_ends_with?: Maybe<String>;
  device_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  AND?: Maybe<SessionRestrictedWhereInput[] | SessionRestrictedWhereInput>;
}

export interface ManufacturerCreateOneInput {
  create?: Maybe<ManufacturerCreateInput>;
}

export interface ReceivedByUpdateManyWithWhereNestedInput {
  where: ReceivedByScalarWhereInput;
  data: ReceivedByUpdateManyDataInput;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface ReceivedByScalarWhereInput {
  _receivedAt?: Maybe<DateTimeInput>;
  _receivedAt_not?: Maybe<DateTimeInput>;
  _receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _receivedAt_lt?: Maybe<DateTimeInput>;
  _receivedAt_lte?: Maybe<DateTimeInput>;
  _receivedAt_gt?: Maybe<DateTimeInput>;
  _receivedAt_gte?: Maybe<DateTimeInput>;
  _readAt?: Maybe<DateTimeInput>;
  _readAt_not?: Maybe<DateTimeInput>;
  _readAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _readAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _readAt_lt?: Maybe<DateTimeInput>;
  _readAt_lte?: Maybe<DateTimeInput>;
  _readAt_gt?: Maybe<DateTimeInput>;
  _readAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ReceivedByScalarWhereInput[] | ReceivedByScalarWhereInput>;
  OR?: Maybe<ReceivedByScalarWhereInput[] | ReceivedByScalarWhereInput>;
  NOT?: Maybe<ReceivedByScalarWhereInput[] | ReceivedByScalarWhereInput>;
}

export interface OrderCreateInput {
  _id?: Maybe<ID_Input>;
  _customerId: PersonCreateOneInput;
  items?: Maybe<ProductCreateManyInput>;
  total: Float;
  status?: Maybe<OrderStatus>;
}

export interface PersonUpdateWithWhereUniqueNestedInput {
  where: PersonWhereUniqueInput;
  data: PersonUpdateDataInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
  _handlerId?: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface PersonUpsertWithWhereUniqueNestedInput {
  where: PersonWhereUniqueInput;
  update: PersonUpdateDataInput;
  create: PersonCreateInput;
}

export interface SenderUpdateDataInput {
  _personId?: Maybe<PersonUpdateOneRequiredInput>;
  name?: Maybe<String>;
  type?: Maybe<SenderType>;
}

export interface PersonScalarWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _createdAt?: Maybe<DateTimeInput>;
  _createdAt_not?: Maybe<DateTimeInput>;
  _createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_lt?: Maybe<DateTimeInput>;
  _createdAt_lte?: Maybe<DateTimeInput>;
  _createdAt_gt?: Maybe<DateTimeInput>;
  _createdAt_gte?: Maybe<DateTimeInput>;
  _updatedAt?: Maybe<DateTimeInput>;
  _updatedAt_not?: Maybe<DateTimeInput>;
  _updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_lt?: Maybe<DateTimeInput>;
  _updatedAt_lte?: Maybe<DateTimeInput>;
  _updatedAt_gt?: Maybe<DateTimeInput>;
  _updatedAt_gte?: Maybe<DateTimeInput>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  AND?: Maybe<PersonScalarWhereInput[] | PersonScalarWhereInput>;
  OR?: Maybe<PersonScalarWhereInput[] | PersonScalarWhereInput>;
  NOT?: Maybe<PersonScalarWhereInput[] | PersonScalarWhereInput>;
}

export interface PersonCreateOneInput {
  create?: Maybe<PersonCreateInput>;
  connect?: Maybe<PersonWhereUniqueInput>;
}

export interface PersonUpdateManyWithWhereNestedInput {
  where: PersonScalarWhereInput;
  data: PersonUpdateManyDataInput;
}

export interface BillingCreateOneInput {
  create?: Maybe<BillingCreateInput>;
}

export interface PersonUpdateManyDataInput {
  password?: Maybe<String>;
  username?: Maybe<String>;
}

export interface AccountCreateManyInput {
  create?: Maybe<AccountCreateInput[] | AccountCreateInput>;
}

export interface ContactUpdateOneInput {
  create?: Maybe<ContactCreateInput>;
  update?: Maybe<ContactUpdateDataInput>;
  upsert?: Maybe<ContactUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface CardCreateManyInput {
  create?: Maybe<CardCreateInput[] | CardCreateInput>;
}

export interface ContactUpdateDataInput {
  emails?: Maybe<ContactUpdateemailsInput>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  country?: Maybe<String>;
  postalCode?: Maybe<String>;
  phones?: Maybe<ContactUpdatephonesInput>;
}

export interface PersonCreateManyInput {
  create?: Maybe<PersonCreateInput[] | PersonCreateInput>;
  connect?: Maybe<PersonWhereUniqueInput[] | PersonWhereUniqueInput>;
}

export interface ContactUpdateemailsInput {
  set?: Maybe<String[] | String>;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface ContactUpdatephonesInput {
  set?: Maybe<String[] | String>;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotificationWhereInput>;
  AND?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
}

export interface ContactUpsertNestedInput {
  update: ContactUpdateDataInput;
  create: ContactCreateInput;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<ProductCategory>;
  description?: Maybe<String>;
  details?: Maybe<Json>;
  manufacturer?: Maybe<ManufacturerUpdateOneInput>;
  price?: Maybe<PriceUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
  shipping?: Maybe<ShippingUpdateOneInput>;
  sku?: Maybe<String>;
}

export interface CareerUpdateOneInput {
  create?: Maybe<CareerCreateInput>;
  update?: Maybe<CareerUpdateDataInput>;
  upsert?: Maybe<CareerUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface DocumentWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _authorId?: Maybe<PersonWhereInput>;
  _createdAt?: Maybe<DateTimeInput>;
  _createdAt_not?: Maybe<DateTimeInput>;
  _createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_lt?: Maybe<DateTimeInput>;
  _createdAt_lte?: Maybe<DateTimeInput>;
  _createdAt_gt?: Maybe<DateTimeInput>;
  _createdAt_gte?: Maybe<DateTimeInput>;
  _publishedAt?: Maybe<DateTimeInput>;
  _publishedAt_not?: Maybe<DateTimeInput>;
  _publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _publishedAt_lt?: Maybe<DateTimeInput>;
  _publishedAt_lte?: Maybe<DateTimeInput>;
  _publishedAt_gt?: Maybe<DateTimeInput>;
  _publishedAt_gte?: Maybe<DateTimeInput>;
  _updatedAt?: Maybe<DateTimeInput>;
  _updatedAt_not?: Maybe<DateTimeInput>;
  _updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_lt?: Maybe<DateTimeInput>;
  _updatedAt_lte?: Maybe<DateTimeInput>;
  _updatedAt_gt?: Maybe<DateTimeInput>;
  _updatedAt_gte?: Maybe<DateTimeInput>;
  category?: Maybe<DocumentCategory>;
  category_not?: Maybe<DocumentCategory>;
  category_in?: Maybe<DocumentCategory[] | DocumentCategory>;
  category_not_in?: Maybe<DocumentCategory[] | DocumentCategory>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  subtitle?: Maybe<String>;
  subtitle_not?: Maybe<String>;
  subtitle_in?: Maybe<String[] | String>;
  subtitle_not_in?: Maybe<String[] | String>;
  subtitle_lt?: Maybe<String>;
  subtitle_lte?: Maybe<String>;
  subtitle_gt?: Maybe<String>;
  subtitle_gte?: Maybe<String>;
  subtitle_contains?: Maybe<String>;
  subtitle_not_contains?: Maybe<String>;
  subtitle_starts_with?: Maybe<String>;
  subtitle_not_starts_with?: Maybe<String>;
  subtitle_ends_with?: Maybe<String>;
  subtitle_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<DocumentWhereInput[] | DocumentWhereInput>;
}

export interface CareerUpdateDataInput {
  company?: Maybe<String>;
  experience?: Maybe<ExperienceUpdateOneInput>;
  position?: Maybe<String>;
}

export interface ProductUpdateManyDataInput {
  name?: Maybe<String>;
  category?: Maybe<ProductCategory>;
  description?: Maybe<String>;
  details?: Maybe<Json>;
  quantity?: Maybe<Int>;
  sku?: Maybe<String>;
}

export interface ExperienceUpdateOneInput {
  create?: Maybe<ExperienceCreateInput>;
  update?: Maybe<ExperienceUpdateDataInput>;
  upsert?: Maybe<ExperienceUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ExperienceUpdateDataInput {
  company?: Maybe<String>;
  position?: Maybe<String>;
  description?: Maybe<String>;
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
}

export interface ReceivedByRestrictedWhereInput {
  _receivedAt?: Maybe<DateTimeInput>;
  _receivedAt_not?: Maybe<DateTimeInput>;
  _receivedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _receivedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _receivedAt_lt?: Maybe<DateTimeInput>;
  _receivedAt_lte?: Maybe<DateTimeInput>;
  _receivedAt_gt?: Maybe<DateTimeInput>;
  _receivedAt_gte?: Maybe<DateTimeInput>;
  _readAt?: Maybe<DateTimeInput>;
  _readAt_not?: Maybe<DateTimeInput>;
  _readAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _readAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _readAt_lt?: Maybe<DateTimeInput>;
  _readAt_lte?: Maybe<DateTimeInput>;
  _readAt_gt?: Maybe<DateTimeInput>;
  _readAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ReceivedByRestrictedWhereInput[] | ReceivedByRestrictedWhereInput
  >;
}

export interface ExperienceUpsertNestedInput {
  update: ExperienceUpdateDataInput;
  create: ExperienceCreateInput;
}

export interface PriceUpsertNestedInput {
  update: PriceUpdateDataInput;
  create: PriceCreateInput;
}

export interface CareerUpsertNestedInput {
  update: CareerUpdateDataInput;
  create: CareerCreateInput;
}

export interface ProductWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _handlerId?: Maybe<ID_Input>;
  _handlerId_not?: Maybe<ID_Input>;
  _handlerId_in?: Maybe<ID_Input[] | ID_Input>;
  _handlerId_not_in?: Maybe<ID_Input[] | ID_Input>;
  _handlerId_lt?: Maybe<ID_Input>;
  _handlerId_lte?: Maybe<ID_Input>;
  _handlerId_gt?: Maybe<ID_Input>;
  _handlerId_gte?: Maybe<ID_Input>;
  _handlerId_contains?: Maybe<ID_Input>;
  _handlerId_not_contains?: Maybe<ID_Input>;
  _handlerId_starts_with?: Maybe<ID_Input>;
  _handlerId_not_starts_with?: Maybe<ID_Input>;
  _handlerId_ends_with?: Maybe<ID_Input>;
  _handlerId_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<ProductCategory>;
  category_not?: Maybe<ProductCategory>;
  category_in?: Maybe<ProductCategory[] | ProductCategory>;
  category_not_in?: Maybe<ProductCategory[] | ProductCategory>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  manufacturer?: Maybe<ManufacturerWhereInput>;
  price?: Maybe<PriceWhereInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  shipping?: Maybe<ShippingWhereInput>;
  sku?: Maybe<String>;
  sku_not?: Maybe<String>;
  sku_in?: Maybe<String[] | String>;
  sku_not_in?: Maybe<String[] | String>;
  sku_lt?: Maybe<String>;
  sku_lte?: Maybe<String>;
  sku_gt?: Maybe<String>;
  sku_gte?: Maybe<String>;
  sku_contains?: Maybe<String>;
  sku_not_contains?: Maybe<String>;
  sku_starts_with?: Maybe<String>;
  sku_not_starts_with?: Maybe<String>;
  sku_ends_with?: Maybe<String>;
  sku_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface NameUpdateOneRequiredInput {
  create?: Maybe<NameCreateInput>;
  update?: Maybe<NameUpdateDataInput>;
  upsert?: Maybe<NameUpsertNestedInput>;
}

export interface ManufacturerUpdateDataInput {
  model?: Maybe<String>;
  releaseDate?: Maybe<DateTimeInput>;
}

export interface NameUpdateDataInput {
  first?: Maybe<String>;
  last?: Maybe<String>;
  middle?: Maybe<String>;
  preferred?: Maybe<String>;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface NameUpsertNestedInput {
  update: NameUpdateDataInput;
  create: NameCreateInput;
}

export interface ShippingCreateOneInput {
  create?: Maybe<ShippingCreateInput>;
}

export interface ProfileUpdateOneInput {
  create?: Maybe<ProfileCreateInput>;
  update?: Maybe<ProfileUpdateDataInput>;
  upsert?: Maybe<ProfileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface ManufacturerCreateInput {
  model: String;
  releaseDate: DateTimeInput;
}

export interface ProfileUpdateDataInput {
  avatar?: Maybe<String>;
  gender?: Maybe<Gender>;
  headline?: Maybe<String>;
}

export interface ProductCreateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput;
  create: ProfileCreateInput;
}

export interface SenderUpsertNestedInput {
  update: SenderUpdateDataInput;
  create: SenderCreateInput;
}

export interface SessionUpdateManyInput {
  create?: Maybe<SessionCreateInput[] | SessionCreateInput>;
  deleteMany?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  updateMany?: Maybe<
    | SessionUpdateManyWithWhereNestedInput[]
    | SessionUpdateManyWithWhereNestedInput
  >;
}

export interface CommentCreateInput {
  _id?: Maybe<ID_Input>;
  _authorId: PersonCreateOneInput;
  _discussionId: ID_Input;
  _parentId?: Maybe<CommentCreateOneInput>;
  content: String;
  fullSlug?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<CommentType>;
}

export interface SessionScalarWhereInput {
  device?: Maybe<String>;
  device_not?: Maybe<String>;
  device_in?: Maybe<String[] | String>;
  device_not_in?: Maybe<String[] | String>;
  device_lt?: Maybe<String>;
  device_lte?: Maybe<String>;
  device_gt?: Maybe<String>;
  device_gte?: Maybe<String>;
  device_contains?: Maybe<String>;
  device_not_contains?: Maybe<String>;
  device_starts_with?: Maybe<String>;
  device_not_starts_with?: Maybe<String>;
  device_ends_with?: Maybe<String>;
  device_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  token?: Maybe<String>;
  token_not?: Maybe<String>;
  token_in?: Maybe<String[] | String>;
  token_not_in?: Maybe<String[] | String>;
  token_lt?: Maybe<String>;
  token_lte?: Maybe<String>;
  token_gt?: Maybe<String>;
  token_gte?: Maybe<String>;
  token_contains?: Maybe<String>;
  token_not_contains?: Maybe<String>;
  token_starts_with?: Maybe<String>;
  token_not_starts_with?: Maybe<String>;
  token_ends_with?: Maybe<String>;
  token_not_ends_with?: Maybe<String>;
  AND?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  OR?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
  NOT?: Maybe<SessionScalarWhereInput[] | SessionScalarWhereInput>;
}

export interface BillingCreateInput {
  accounts?: Maybe<AccountCreateManyInput>;
  cards?: Maybe<CardCreateManyInput>;
}

export interface SessionUpdateManyWithWhereNestedInput {
  where: SessionScalarWhereInput;
  data: SessionUpdateManyDataInput;
}

export interface CardCreateInput {
  name: String;
  number: Int;
  cvv: Int;
  expiration: DateTimeInput;
  type?: Maybe<CardType>;
}

export interface SessionUpdateManyDataInput {
  device?: Maybe<String>;
  location?: Maybe<String>;
  token?: Maybe<String>;
}

export interface CommentWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _authorId?: Maybe<PersonWhereInput>;
  _createdAt?: Maybe<DateTimeInput>;
  _createdAt_not?: Maybe<DateTimeInput>;
  _createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_lt?: Maybe<DateTimeInput>;
  _createdAt_lte?: Maybe<DateTimeInput>;
  _createdAt_gt?: Maybe<DateTimeInput>;
  _createdAt_gte?: Maybe<DateTimeInput>;
  _discussionId?: Maybe<ID_Input>;
  _discussionId_not?: Maybe<ID_Input>;
  _discussionId_in?: Maybe<ID_Input[] | ID_Input>;
  _discussionId_not_in?: Maybe<ID_Input[] | ID_Input>;
  _discussionId_lt?: Maybe<ID_Input>;
  _discussionId_lte?: Maybe<ID_Input>;
  _discussionId_gt?: Maybe<ID_Input>;
  _discussionId_gte?: Maybe<ID_Input>;
  _discussionId_contains?: Maybe<ID_Input>;
  _discussionId_not_contains?: Maybe<ID_Input>;
  _discussionId_starts_with?: Maybe<ID_Input>;
  _discussionId_not_starts_with?: Maybe<ID_Input>;
  _discussionId_ends_with?: Maybe<ID_Input>;
  _discussionId_not_ends_with?: Maybe<ID_Input>;
  _parentId?: Maybe<CommentWhereInput>;
  _updatedAt?: Maybe<DateTimeInput>;
  _updatedAt_not?: Maybe<DateTimeInput>;
  _updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _updatedAt_lt?: Maybe<DateTimeInput>;
  _updatedAt_lte?: Maybe<DateTimeInput>;
  _updatedAt_gt?: Maybe<DateTimeInput>;
  _updatedAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  fullSlug?: Maybe<String>;
  fullSlug_not?: Maybe<String>;
  fullSlug_in?: Maybe<String[] | String>;
  fullSlug_not_in?: Maybe<String[] | String>;
  fullSlug_lt?: Maybe<String>;
  fullSlug_lte?: Maybe<String>;
  fullSlug_gt?: Maybe<String>;
  fullSlug_gte?: Maybe<String>;
  fullSlug_contains?: Maybe<String>;
  fullSlug_not_contains?: Maybe<String>;
  fullSlug_starts_with?: Maybe<String>;
  fullSlug_not_starts_with?: Maybe<String>;
  fullSlug_ends_with?: Maybe<String>;
  fullSlug_not_ends_with?: Maybe<String>;
  slug?: Maybe<String>;
  slug_not?: Maybe<String>;
  slug_in?: Maybe<String[] | String>;
  slug_not_in?: Maybe<String[] | String>;
  slug_lt?: Maybe<String>;
  slug_lte?: Maybe<String>;
  slug_gt?: Maybe<String>;
  slug_gte?: Maybe<String>;
  slug_contains?: Maybe<String>;
  slug_not_contains?: Maybe<String>;
  slug_starts_with?: Maybe<String>;
  slug_not_starts_with?: Maybe<String>;
  slug_ends_with?: Maybe<String>;
  slug_not_ends_with?: Maybe<String>;
  type?: Maybe<CommentType>;
  type_not?: Maybe<CommentType>;
  type_in?: Maybe<CommentType[] | CommentType>;
  type_not_in?: Maybe<CommentType[] | CommentType>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface PersonUpsertNestedInput {
  update: PersonUpdateDataInput;
  create: PersonCreateInput;
}

export interface PersonUpdateManyMutationInput {
  password?: Maybe<String>;
  username?: Maybe<String>;
}

export interface CommentUpdateOneInput {
  create?: Maybe<CommentCreateInput>;
  update?: Maybe<CommentUpdateDataInput>;
  upsert?: Maybe<CommentUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CommentWhereUniqueInput>;
}

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface CommentUpdateDataInput {
  _authorId?: Maybe<PersonUpdateOneRequiredInput>;
  _discussionId?: Maybe<ID_Input>;
  _parentId?: Maybe<CommentUpdateOneInput>;
  content?: Maybe<String>;
  fullSlug?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<CommentType>;
}

export interface ShippingUpdateDataInput {
  depth?: Maybe<Float>;
  height?: Maybe<Float>;
  scale?: Maybe<DimensionScale>;
  weight?: Maybe<Float>;
  width?: Maybe<Float>;
}

export interface CommentUpsertNestedInput {
  update: CommentUpdateDataInput;
  create: CommentCreateInput;
}

export interface ManufacturerWhereInput {
  model?: Maybe<String>;
  model_not?: Maybe<String>;
  model_in?: Maybe<String[] | String>;
  model_not_in?: Maybe<String[] | String>;
  model_lt?: Maybe<String>;
  model_lte?: Maybe<String>;
  model_gt?: Maybe<String>;
  model_gte?: Maybe<String>;
  model_contains?: Maybe<String>;
  model_not_contains?: Maybe<String>;
  model_starts_with?: Maybe<String>;
  model_not_starts_with?: Maybe<String>;
  model_ends_with?: Maybe<String>;
  model_not_ends_with?: Maybe<String>;
  releaseDate?: Maybe<DateTimeInput>;
  releaseDate_not?: Maybe<DateTimeInput>;
  releaseDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  releaseDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  releaseDate_lt?: Maybe<DateTimeInput>;
  releaseDate_lte?: Maybe<DateTimeInput>;
  releaseDate_gt?: Maybe<DateTimeInput>;
  releaseDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ManufacturerWhereInput[] | ManufacturerWhereInput>;
}

export interface CommentUpdateManyMutationInput {
  _discussionId?: Maybe<ID_Input>;
  content?: Maybe<String>;
  fullSlug?: Maybe<String>;
  slug?: Maybe<String>;
  type?: Maybe<CommentType>;
}

export interface OrderUpdateInput {
  _customerId?: Maybe<PersonUpdateOneRequiredInput>;
  items?: Maybe<ProductUpdateManyInput>;
  total?: Maybe<Float>;
  status?: Maybe<OrderStatus>;
}

export interface ReceivedByUpdateManyInput {
  create?: Maybe<ReceivedByCreateInput[] | ReceivedByCreateInput>;
  deleteMany?: Maybe<ReceivedByScalarWhereInput[] | ReceivedByScalarWhereInput>;
  updateMany?: Maybe<
    | ReceivedByUpdateManyWithWhereNestedInput[]
    | ReceivedByUpdateManyWithWhereNestedInput
  >;
}

export interface ProductCreateInput {
  _id?: Maybe<ID_Input>;
  _handlerId?: Maybe<ID_Input>;
  name: String;
  category?: Maybe<ProductCategory>;
  description: String;
  details?: Maybe<Json>;
  manufacturer?: Maybe<ManufacturerCreateOneInput>;
  price: PriceCreateOneInput;
  quantity?: Maybe<Int>;
  shipping?: Maybe<ShippingCreateOneInput>;
  sku?: Maybe<String>;
}

export interface NotificationUpdatereceiverInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface SenderUpdateOneRequiredInput {
  create?: Maybe<SenderCreateInput>;
  update?: Maybe<SenderUpdateDataInput>;
  upsert?: Maybe<SenderUpsertNestedInput>;
}

export interface DocumentCreateInput {
  _id?: Maybe<ID_Input>;
  _authorId: PersonCreateOneInput;
  _publishedAt?: Maybe<DateTimeInput>;
  category?: Maybe<DocumentCategory>;
  content: String;
  subtitle?: Maybe<String>;
  title: String;
}

export interface AccountCreateInput {
  number?: Maybe<Int>;
  routing?: Maybe<Int>;
  type?: Maybe<AccountType>;
}

export interface DocumentUpdateInput {
  _authorId?: Maybe<PersonUpdateOneRequiredInput>;
  _publishedAt?: Maybe<DateTimeInput>;
  category?: Maybe<DocumentCategory>;
  content?: Maybe<String>;
  subtitle?: Maybe<String>;
  title?: Maybe<String>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface DocumentUpdateManyMutationInput {
  _publishedAt?: Maybe<DateTimeInput>;
  category?: Maybe<DocumentCategory>;
  content?: Maybe<String>;
  subtitle?: Maybe<String>;
  title?: Maybe<String>;
}

export interface NotificationWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _createdAt?: Maybe<DateTimeInput>;
  _createdAt_not?: Maybe<DateTimeInput>;
  _createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _createdAt_lt?: Maybe<DateTimeInput>;
  _createdAt_lte?: Maybe<DateTimeInput>;
  _createdAt_gt?: Maybe<DateTimeInput>;
  _createdAt_gte?: Maybe<DateTimeInput>;
  _sentAt?: Maybe<DateTimeInput>;
  _sentAt_not?: Maybe<DateTimeInput>;
  _sentAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _sentAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  _sentAt_lt?: Maybe<DateTimeInput>;
  _sentAt_lte?: Maybe<DateTimeInput>;
  _sentAt_gt?: Maybe<DateTimeInput>;
  _sentAt_gte?: Maybe<DateTimeInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  receivedBy_some?: Maybe<ReceivedByWhereInput>;
  receivedBy_every?: Maybe<ReceivedByRestrictedWhereInput>;
  receivedBy_none?: Maybe<ReceivedByRestrictedWhereInput>;
  sender?: Maybe<SenderWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
}

export interface NotificationCreateInput {
  _id?: Maybe<ID_Input>;
  _sentAt: DateTimeInput;
  receiver?: Maybe<NotificationCreatereceiverInput>;
  message: String;
  receivedBy?: Maybe<ReceivedByCreateManyInput>;
  sender: SenderCreateOneInput;
  title: String;
}

export interface ManufacturerUpdateOneInput {
  create?: Maybe<ManufacturerCreateInput>;
  update?: Maybe<ManufacturerUpdateDataInput>;
  upsert?: Maybe<ManufacturerUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
}

export interface NotificationCreatereceiverInput {
  set?: Maybe<ID_Input[] | ID_Input>;
}

export interface NotificationUpdateManyMutationInput {
  _sentAt?: Maybe<DateTimeInput>;
  receiver?: Maybe<NotificationUpdatereceiverInput>;
  message?: Maybe<String>;
  title?: Maybe<String>;
}

export interface SenderCreateInput {
  _personId: PersonCreateOneInput;
  name: String;
  type: SenderType;
}

export interface SenderCreateOneInput {
  create?: Maybe<SenderCreateInput>;
}

export interface ReceivedByCreateInput {
  _personId: PersonCreateOneInput;
  _receivedAt: DateTimeInput;
  _readAt: DateTimeInput;
}

export interface ReceivedByCreateManyInput {
  create?: Maybe<ReceivedByCreateInput[] | ReceivedByCreateInput>;
}

export interface PersonCreateInput {
  _id?: Maybe<ID_Input>;
  billing?: Maybe<BillingCreateOneInput>;
  connections?: Maybe<PersonCreateManyInput>;
  contact?: Maybe<ContactCreateOneInput>;
  career?: Maybe<CareerCreateOneInput>;
  name: NameCreateOneInput;
  password: String;
  profile?: Maybe<ProfileCreateOneInput>;
  sessions?: Maybe<SessionCreateManyInput>;
  username: String;
}

export interface OrderWhereInput {
  _id?: Maybe<ID_Input>;
  _id_not?: Maybe<ID_Input>;
  _id_in?: Maybe<ID_Input[] | ID_Input>;
  _id_not_in?: Maybe<ID_Input[] | ID_Input>;
  _id_lt?: Maybe<ID_Input>;
  _id_lte?: Maybe<ID_Input>;
  _id_gt?: Maybe<ID_Input>;
  _id_gte?: Maybe<ID_Input>;
  _id_contains?: Maybe<ID_Input>;
  _id_not_contains?: Maybe<ID_Input>;
  _id_starts_with?: Maybe<ID_Input>;
  _id_not_starts_with?: Maybe<ID_Input>;
  _id_ends_with?: Maybe<ID_Input>;
  _id_not_ends_with?: Maybe<ID_Input>;
  _customerId?: Maybe<PersonWhereInput>;
  items_some?: Maybe<ProductWhereInput>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  status?: Maybe<OrderStatus>;
  status_not?: Maybe<OrderStatus>;
  status_in?: Maybe<OrderStatus[] | OrderStatus>;
  status_not_in?: Maybe<OrderStatus[] | OrderStatus>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  _id: Maybe<ID_Input>;
}>;

export interface PersonUpdateInput {
  billing?: Maybe<BillingUpdateOneInput>;
  connections?: Maybe<PersonUpdateManyInput>;
  contact?: Maybe<ContactUpdateOneInput>;
  career?: Maybe<CareerUpdateOneInput>;
  name?: Maybe<NameUpdateOneRequiredInput>;
  password?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneInput>;
  sessions?: Maybe<SessionUpdateManyInput>;
  username?: Maybe<String>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ProductPreviousValues {
  _id: ID_Output;
  _handlerId: ID_Output;
  name: String;
  category?: ProductCategory;
  description: String;
  details?: Json;
  quantity: Int;
  sku?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _handlerId: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<ProductCategory>;
  description: () => Promise<String>;
  details: () => Promise<Json>;
  quantity: () => Promise<Int>;
  sku: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _handlerId: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<ProductCategory>>;
  description: () => Promise<AsyncIterator<String>>;
  details: () => Promise<AsyncIterator<Json>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  sku: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Career {
  company: String;
  experience?: Experience | null;
  position: String;
}

export interface CareerPromise extends Promise<Career>, Fragmentable {
  company: () => Promise<String>;
  experience: <T = ExperiencePromise>() => T;
  position: () => Promise<String>;
}

export interface CareerSubscription
  extends Promise<AsyncIterator<Career>>,
    Fragmentable {
  company: () => Promise<AsyncIterator<String>>;
  experience: <T = ExperienceSubscription>() => T;
  position: () => Promise<AsyncIterator<String>>;
}

export interface CareerNullablePromise
  extends Promise<Career | null>,
    Fragmentable {
  company: () => Promise<String>;
  experience: <T = ExperiencePromise>() => T;
  position: () => Promise<String>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface Contact {
  emails: String[];
  address1: String;
  address2: String;
  city: String;
  state: String;
  country: String;
  postalCode: String;
  phones: String[];
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  emails: () => Promise<String[]>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postalCode: () => Promise<String>;
  phones: () => Promise<String[]>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  emails: () => Promise<AsyncIterator<String[]>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  phones: () => Promise<AsyncIterator<String[]>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  emails: () => Promise<String[]>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  country: () => Promise<String>;
  postalCode: () => Promise<String>;
  phones: () => Promise<String[]>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Card {
  name: String;
  number: Int;
  cvv: Int;
  expiration: DateTimeOutput;
  type?: CardType;
}

export interface CardPromise extends Promise<Card>, Fragmentable {
  name: () => Promise<String>;
  number: () => Promise<Int>;
  cvv: () => Promise<Int>;
  expiration: () => Promise<DateTimeOutput>;
  type: () => Promise<CardType>;
}

export interface CardSubscription
  extends Promise<AsyncIterator<Card>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  cvv: () => Promise<AsyncIterator<Int>>;
  expiration: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<CardType>>;
}

export interface CardNullablePromise
  extends Promise<Card | null>,
    Fragmentable {
  name: () => Promise<String>;
  number: () => Promise<Int>;
  cvv: () => Promise<Int>;
  expiration: () => Promise<DateTimeOutput>;
  type: () => Promise<CardType>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface Sender {
  name: String;
  type: SenderType;
}

export interface SenderPromise extends Promise<Sender>, Fragmentable {
  _personId: <T = PersonPromise>() => T;
  name: () => Promise<String>;
  type: () => Promise<SenderType>;
}

export interface SenderSubscription
  extends Promise<AsyncIterator<Sender>>,
    Fragmentable {
  _personId: <T = PersonSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<SenderType>>;
}

export interface SenderNullablePromise
  extends Promise<Sender | null>,
    Fragmentable {
  _personId: <T = PersonPromise>() => T;
  name: () => Promise<String>;
  type: () => Promise<SenderType>;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ReceivedBy {
  _receivedAt: DateTimeOutput;
  _readAt: DateTimeOutput;
}

export interface ReceivedByPromise extends Promise<ReceivedBy>, Fragmentable {
  _personId: <T = PersonPromise>() => T;
  _receivedAt: () => Promise<DateTimeOutput>;
  _readAt: () => Promise<DateTimeOutput>;
}

export interface ReceivedBySubscription
  extends Promise<AsyncIterator<ReceivedBy>>,
    Fragmentable {
  _personId: <T = PersonSubscription>() => T;
  _receivedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _readAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ReceivedByNullablePromise
  extends Promise<ReceivedBy | null>,
    Fragmentable {
  _personId: <T = PersonPromise>() => T;
  _receivedAt: () => Promise<DateTimeOutput>;
  _readAt: () => Promise<DateTimeOutput>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Notification {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _sentAt: DateTimeOutput;
  receiver: ID_Output[];
  message: String;
  receivedBy?: <T = FragmentableArray<ReceivedBy>>() => T;
  sender: Sender;
  title: String;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _sentAt: () => Promise<DateTimeOutput>;
  receiver: () => Promise<ID_Output[]>;
  message: () => Promise<String>;
  receivedBy: <T = FragmentableArray<ReceivedBy>>() => T;
  sender: <T = SenderPromise>() => T;
  title: () => Promise<String>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receiver: () => Promise<AsyncIterator<ID_Output[]>>;
  message: () => Promise<AsyncIterator<String>>;
  receivedBy: <T = Promise<AsyncIterator<ReceivedBySubscription>>>() => T;
  sender: <T = SenderSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
}

export interface NotificationNullablePromise
  extends Promise<Notification | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _sentAt: () => Promise<DateTimeOutput>;
  receiver: () => Promise<ID_Output[]>;
  message: () => Promise<String>;
  receivedBy: <T = FragmentableArray<ReceivedBy>>() => T;
  sender: <T = SenderPromise>() => T;
  title: () => Promise<String>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface AggregateDocument {
  count: Int;
}

export interface AggregateDocumentPromise
  extends Promise<AggregateDocument>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDocumentSubscription
  extends Promise<AsyncIterator<AggregateDocument>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Person {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _updatedAt: DateTimeOutput;
  billing?: Billing | null;
  contact?: Contact | null;
  career?: Career | null;
  name: Name;
  password: String;
  profile?: Profile | null;
  sessions?: <T = FragmentableArray<Session>>() => T;
  username: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _updatedAt: () => Promise<DateTimeOutput>;
  billing: <T = BillingPromise>() => T;
  connections: <T = FragmentableArray<Person>>(args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactPromise>() => T;
  career: <T = CareerPromise>() => T;
  name: <T = NamePromise>() => T;
  password: () => Promise<String>;
  profile: <T = ProfilePromise>() => T;
  sessions: <T = FragmentableArray<Session>>() => T;
  username: () => Promise<String>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  billing: <T = BillingSubscription>() => T;
  connections: <T = Promise<AsyncIterator<PersonSubscription>>>(args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactSubscription>() => T;
  career: <T = CareerSubscription>() => T;
  name: <T = NameSubscription>() => T;
  password: () => Promise<AsyncIterator<String>>;
  profile: <T = ProfileSubscription>() => T;
  sessions: <T = Promise<AsyncIterator<SessionSubscription>>>() => T;
  username: () => Promise<AsyncIterator<String>>;
}

export interface PersonNullablePromise
  extends Promise<Person | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _updatedAt: () => Promise<DateTimeOutput>;
  billing: <T = BillingPromise>() => T;
  connections: <T = FragmentableArray<Person>>(args?: {
    where?: PersonWhereInput;
    orderBy?: PersonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contact: <T = ContactPromise>() => T;
  career: <T = CareerPromise>() => T;
  name: <T = NamePromise>() => T;
  password: () => Promise<String>;
  profile: <T = ProfilePromise>() => T;
  sessions: <T = FragmentableArray<Session>>() => T;
  username: () => Promise<String>;
}

export interface DocumentEdge {
  node: Document;
  cursor: String;
}

export interface DocumentEdgePromise
  extends Promise<DocumentEdge>,
    Fragmentable {
  node: <T = DocumentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DocumentEdgeSubscription
  extends Promise<AsyncIterator<DocumentEdge>>,
    Fragmentable {
  node: <T = DocumentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Price {
  list: Float;
  retail: Float;
  savings?: Float;
  savingsPct?: Float;
}

export interface PricePromise extends Promise<Price>, Fragmentable {
  list: () => Promise<Float>;
  retail: () => Promise<Float>;
  savings: () => Promise<Float>;
  savingsPct: () => Promise<Float>;
}

export interface PriceSubscription
  extends Promise<AsyncIterator<Price>>,
    Fragmentable {
  list: () => Promise<AsyncIterator<Float>>;
  retail: () => Promise<AsyncIterator<Float>>;
  savings: () => Promise<AsyncIterator<Float>>;
  savingsPct: () => Promise<AsyncIterator<Float>>;
}

export interface PriceNullablePromise
  extends Promise<Price | null>,
    Fragmentable {
  list: () => Promise<Float>;
  retail: () => Promise<Float>;
  savings: () => Promise<Float>;
  savingsPct: () => Promise<Float>;
}

export interface DocumentConnection {
  pageInfo: PageInfo;
  edges: DocumentEdge[];
}

export interface DocumentConnectionPromise
  extends Promise<DocumentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DocumentEdge>>() => T;
  aggregate: <T = AggregateDocumentPromise>() => T;
}

export interface DocumentConnectionSubscription
  extends Promise<AsyncIterator<DocumentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DocumentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDocumentSubscription>() => T;
}

export interface Name {
  first: String;
  last: String;
  middle?: String;
  preferred?: String;
}

export interface NamePromise extends Promise<Name>, Fragmentable {
  first: () => Promise<String>;
  last: () => Promise<String>;
  middle: () => Promise<String>;
  preferred: () => Promise<String>;
}

export interface NameSubscription
  extends Promise<AsyncIterator<Name>>,
    Fragmentable {
  first: () => Promise<AsyncIterator<String>>;
  last: () => Promise<AsyncIterator<String>>;
  middle: () => Promise<AsyncIterator<String>>;
  preferred: () => Promise<AsyncIterator<String>>;
}

export interface NameNullablePromise
  extends Promise<Name | null>,
    Fragmentable {
  first: () => Promise<String>;
  last: () => Promise<String>;
  middle: () => Promise<String>;
  preferred: () => Promise<String>;
}

export interface Document {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _publishedAt?: DateTimeOutput;
  _updatedAt: DateTimeOutput;
  category: DocumentCategory;
  content: String;
  subtitle?: String;
  title: String;
}

export interface DocumentPromise extends Promise<Document>, Fragmentable {
  _id: () => Promise<ID_Output>;
  _authorId: <T = PersonPromise>() => T;
  _createdAt: () => Promise<DateTimeOutput>;
  _publishedAt: () => Promise<DateTimeOutput>;
  _updatedAt: () => Promise<DateTimeOutput>;
  category: () => Promise<DocumentCategory>;
  content: () => Promise<String>;
  subtitle: () => Promise<String>;
  title: () => Promise<String>;
}

export interface DocumentSubscription
  extends Promise<AsyncIterator<Document>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _authorId: <T = PersonSubscription>() => T;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<DocumentCategory>>;
  content: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface DocumentNullablePromise
  extends Promise<Document | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _authorId: <T = PersonPromise>() => T;
  _createdAt: () => Promise<DateTimeOutput>;
  _publishedAt: () => Promise<DateTimeOutput>;
  _updatedAt: () => Promise<DateTimeOutput>;
  category: () => Promise<DocumentCategory>;
  content: () => Promise<String>;
  subtitle: () => Promise<String>;
  title: () => Promise<String>;
}

export interface PersonPreviousValues {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _updatedAt: DateTimeOutput;
  password: String;
  username: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _updatedAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  username: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Order {
  _id: ID_Output;
  total: Float;
  status: OrderStatus;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  _id: () => Promise<ID_Output>;
  _customerId: <T = PersonPromise>() => T;
  items: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Float>;
  status: () => Promise<OrderStatus>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _customerId: <T = PersonSubscription>() => T;
  items: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _customerId: <T = PersonPromise>() => T;
  items: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  total: () => Promise<Float>;
  status: () => Promise<OrderStatus>;
}

export interface Profile {
  avatar?: String;
  gender?: Gender;
  headline?: String;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  avatar: () => Promise<String>;
  gender: () => Promise<Gender>;
  headline: () => Promise<String>;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  avatar: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  headline: () => Promise<AsyncIterator<String>>;
}

export interface ProfileNullablePromise
  extends Promise<Profile | null>,
    Fragmentable {
  avatar: () => Promise<String>;
  gender: () => Promise<Gender>;
  headline: () => Promise<String>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  _id: ID_Output;
  total: Float;
  status: OrderStatus;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  status: () => Promise<OrderStatus>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CommentPreviousValues {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _discussionId: ID_Output;
  _updatedAt: DateTimeOutput;
  content: String;
  fullSlug?: String;
  slug?: String;
  type?: CommentType;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _discussionId: () => Promise<ID_Output>;
  _updatedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  fullSlug: () => Promise<String>;
  slug: () => Promise<String>;
  type: () => Promise<CommentType>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _discussionId: () => Promise<AsyncIterator<ID_Output>>;
  _updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  fullSlug: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<CommentType>>;
}

export interface Shipping {
  depth: Float;
  height: Float;
  scale: DimensionScale;
  weight: Float;
  width: Float;
}

export interface ShippingPromise extends Promise<Shipping>, Fragmentable {
  depth: () => Promise<Float>;
  height: () => Promise<Float>;
  scale: () => Promise<DimensionScale>;
  weight: () => Promise<Float>;
  width: () => Promise<Float>;
}

export interface ShippingSubscription
  extends Promise<AsyncIterator<Shipping>>,
    Fragmentable {
  depth: () => Promise<AsyncIterator<Float>>;
  height: () => Promise<AsyncIterator<Float>>;
  scale: () => Promise<AsyncIterator<DimensionScale>>;
  weight: () => Promise<AsyncIterator<Float>>;
  width: () => Promise<AsyncIterator<Float>>;
}

export interface ShippingNullablePromise
  extends Promise<Shipping | null>,
    Fragmentable {
  depth: () => Promise<Float>;
  height: () => Promise<Float>;
  scale: () => Promise<DimensionScale>;
  weight: () => Promise<Float>;
  width: () => Promise<Float>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Product {
  _id: ID_Output;
  _handlerId: ID_Output;
  name: String;
  category?: ProductCategory;
  description: String;
  details?: Json;
  manufacturer?: Manufacturer | null;
  price: Price;
  quantity: Int;
  shipping?: Shipping | null;
  sku?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  _id: () => Promise<ID_Output>;
  _handlerId: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<ProductCategory>;
  description: () => Promise<String>;
  details: () => Promise<Json>;
  manufacturer: <T = ManufacturerPromise>() => T;
  price: <T = PricePromise>() => T;
  quantity: () => Promise<Int>;
  shipping: <T = ShippingPromise>() => T;
  sku: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _handlerId: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<ProductCategory>>;
  description: () => Promise<AsyncIterator<String>>;
  details: () => Promise<AsyncIterator<Json>>;
  manufacturer: <T = ManufacturerSubscription>() => T;
  price: <T = PriceSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  shipping: <T = ShippingSubscription>() => T;
  sku: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _handlerId: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<ProductCategory>;
  description: () => Promise<String>;
  details: () => Promise<Json>;
  manufacturer: <T = ManufacturerPromise>() => T;
  price: <T = PricePromise>() => T;
  quantity: () => Promise<Int>;
  shipping: <T = ShippingPromise>() => T;
  sku: () => Promise<String>;
}

export interface DocumentSubscriptionPayload {
  mutation: MutationType;
  node: Document;
  updatedFields: String[];
  previousValues: DocumentPreviousValues;
}

export interface DocumentSubscriptionPayloadPromise
  extends Promise<DocumentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DocumentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DocumentPreviousValuesPromise>() => T;
}

export interface DocumentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DocumentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DocumentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DocumentPreviousValuesSubscription>() => T;
}

export interface Account {
  number?: Int;
  routing?: Int;
  type?: AccountType;
}

export interface AccountPromise extends Promise<Account>, Fragmentable {
  number: () => Promise<Int>;
  routing: () => Promise<Int>;
  type: () => Promise<AccountType>;
}

export interface AccountSubscription
  extends Promise<AsyncIterator<Account>>,
    Fragmentable {
  number: () => Promise<AsyncIterator<Int>>;
  routing: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<AccountType>>;
}

export interface AccountNullablePromise
  extends Promise<Account | null>,
    Fragmentable {
  number: () => Promise<Int>;
  routing: () => Promise<Int>;
  type: () => Promise<AccountType>;
}

export interface DocumentPreviousValues {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _publishedAt?: DateTimeOutput;
  _updatedAt: DateTimeOutput;
  category: DocumentCategory;
  content: String;
  subtitle?: String;
  title: String;
}

export interface DocumentPreviousValuesPromise
  extends Promise<DocumentPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _publishedAt: () => Promise<DateTimeOutput>;
  _updatedAt: () => Promise<DateTimeOutput>;
  category: () => Promise<DocumentCategory>;
  content: () => Promise<String>;
  subtitle: () => Promise<String>;
  title: () => Promise<String>;
}

export interface DocumentPreviousValuesSubscription
  extends Promise<AsyncIterator<DocumentPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  category: () => Promise<AsyncIterator<DocumentCategory>>;
  content: () => Promise<AsyncIterator<String>>;
  subtitle: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Comment {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _discussionId: ID_Output;
  _updatedAt: DateTimeOutput;
  content: String;
  fullSlug?: String;
  slug?: String;
  type?: CommentType;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  _id: () => Promise<ID_Output>;
  _authorId: <T = PersonPromise>() => T;
  _createdAt: () => Promise<DateTimeOutput>;
  _discussionId: () => Promise<ID_Output>;
  _parentId: <T = CommentPromise>() => T;
  _updatedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  fullSlug: () => Promise<String>;
  slug: () => Promise<String>;
  type: () => Promise<CommentType>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _authorId: <T = PersonSubscription>() => T;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _discussionId: () => Promise<AsyncIterator<ID_Output>>;
  _parentId: <T = CommentSubscription>() => T;
  _updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  fullSlug: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<CommentType>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _authorId: <T = PersonPromise>() => T;
  _createdAt: () => Promise<DateTimeOutput>;
  _discussionId: () => Promise<ID_Output>;
  _parentId: <T = CommentPromise>() => T;
  _updatedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  fullSlug: () => Promise<String>;
  slug: () => Promise<String>;
  type: () => Promise<CommentType>;
}

export interface Session {
  device?: String;
  location?: String;
  token?: String;
}

export interface SessionPromise extends Promise<Session>, Fragmentable {
  device: () => Promise<String>;
  location: () => Promise<String>;
  token: () => Promise<String>;
}

export interface SessionSubscription
  extends Promise<AsyncIterator<Session>>,
    Fragmentable {
  device: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface SessionNullablePromise
  extends Promise<Session | null>,
    Fragmentable {
  device: () => Promise<String>;
  location: () => Promise<String>;
  token: () => Promise<String>;
}

export interface NotificationPreviousValues {
  _id: ID_Output;
  _createdAt: DateTimeOutput;
  _sentAt: DateTimeOutput;
  receiver: ID_Output[];
  message: String;
  title: String;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  _id: () => Promise<ID_Output>;
  _createdAt: () => Promise<DateTimeOutput>;
  _sentAt: () => Promise<DateTimeOutput>;
  receiver: () => Promise<ID_Output[]>;
  message: () => Promise<String>;
  title: () => Promise<String>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  _id: () => Promise<AsyncIterator<ID_Output>>;
  _createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  _sentAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  receiver: () => Promise<AsyncIterator<ID_Output[]>>;
  message: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface Manufacturer {
  model: String;
  releaseDate: DateTimeOutput;
}

export interface ManufacturerPromise
  extends Promise<Manufacturer>,
    Fragmentable {
  model: () => Promise<String>;
  releaseDate: () => Promise<DateTimeOutput>;
}

export interface ManufacturerSubscription
  extends Promise<AsyncIterator<Manufacturer>>,
    Fragmentable {
  model: () => Promise<AsyncIterator<String>>;
  releaseDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ManufacturerNullablePromise
  extends Promise<Manufacturer | null>,
    Fragmentable {
  model: () => Promise<String>;
  releaseDate: () => Promise<DateTimeOutput>;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface Experience {
  company: String;
  position: String;
  description?: String;
  start: DateTimeOutput;
  end: DateTimeOutput;
}

export interface ExperiencePromise extends Promise<Experience>, Fragmentable {
  company: () => Promise<String>;
  position: () => Promise<String>;
  description: () => Promise<String>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<Experience>>,
    Fragmentable {
  company: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExperienceNullablePromise
  extends Promise<Experience | null>,
    Fragmentable {
  company: () => Promise<String>;
  position: () => Promise<String>;
  description: () => Promise<String>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
}

export interface Billing {
  accounts?: <T = FragmentableArray<Account>>() => T;
  cards?: <T = FragmentableArray<Card>>() => T;
}

export interface BillingPromise extends Promise<Billing>, Fragmentable {
  accounts: <T = FragmentableArray<Account>>() => T;
  cards: <T = FragmentableArray<Card>>() => T;
}

export interface BillingSubscription
  extends Promise<AsyncIterator<Billing>>,
    Fragmentable {
  accounts: <T = Promise<AsyncIterator<AccountSubscription>>>() => T;
  cards: <T = Promise<AsyncIterator<CardSubscription>>>() => T;
}

export interface BillingNullablePromise
  extends Promise<Billing | null>,
    Fragmentable {
  accounts: <T = FragmentableArray<Account>>() => T;
  cards: <T = FragmentableArray<Card>>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "CommentType",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "DocumentCategory",
    embedded: false
  },
  {
    name: "Document",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "ReceivedBy",
    embedded: true
  },
  {
    name: "Sender",
    embedded: true
  },
  {
    name: "SenderType",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderStatus",
    embedded: false
  },
  {
    name: "Account",
    embedded: true
  },
  {
    name: "AccountType",
    embedded: false
  },
  {
    name: "Billing",
    embedded: true
  },
  {
    name: "Card",
    embedded: true
  },
  {
    name: "CardType",
    embedded: false
  },
  {
    name: "Career",
    embedded: true
  },
  {
    name: "Contact",
    embedded: true
  },
  {
    name: "Email",
    embedded: true
  },
  {
    name: "EmailType",
    embedded: false
  },
  {
    name: "Experience",
    embedded: true
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Name",
    embedded: true
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Phone",
    embedded: true
  },
  {
    name: "PhoneType",
    embedded: false
  },
  {
    name: "Profile",
    embedded: true
  },
  {
    name: "Session",
    embedded: true
  },
  {
    name: "DimensionScale",
    embedded: false
  },
  {
    name: "Manufacturer",
    embedded: true
  },
  {
    name: "Price",
    embedded: true
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProductCategory",
    embedded: false
  },
  {
    name: "Shipping",
    embedded: true
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
