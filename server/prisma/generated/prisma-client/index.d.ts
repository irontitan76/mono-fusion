// Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from 'graphql';
import { makePrismaClientClass, BaseClientOptions, Model } from 'prisma-client-lib';
import { typeDefs } from './prisma-schema';

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  birth: (where?: BirthWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  insight: (where?: InsightWhereInput) => Promise<boolean>;
  media: (where?: MediaWhereInput) => Promise<boolean>;
  metaType: (where?: MetaTypeWhereInput) => Promise<boolean>;
  name: (where?: NameWhereInput) => Promise<boolean>;
  policy: (where?: PolicyWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  sizeType: (where?: SizeTypeWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  birth: (where: BirthWhereUniqueInput) => BirthNullablePromise;
  births: (
    args?: {
      where?: BirthWhereInput;
      orderBy?: BirthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Birth>;
  birthsConnection: (
    args?: {
      where?: BirthWhereInput;
      orderBy?: BirthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BirthConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (
    args?: {
      where?: ContactWhereInput;
      orderBy?: ContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Contact>;
  contactsConnection: (
    args?: {
      where?: ContactWhereInput;
      orderBy?: ContactOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContactConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeeNullablePromise;
  employees: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Employee>;
  employeesConnection: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmployeeConnectionPromise;
  insight: (where: InsightWhereUniqueInput) => InsightNullablePromise;
  insights: (
    args?: {
      where?: InsightWhereInput;
      orderBy?: InsightOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Insight>;
  insightsConnection: (
    args?: {
      where?: InsightWhereInput;
      orderBy?: InsightOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InsightConnectionPromise;
  media: (where: MediaWhereUniqueInput) => MediaNullablePromise;
  medias: (
    args?: {
      where?: MediaWhereInput;
      orderBy?: MediaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Media>;
  mediasConnection: (
    args?: {
      where?: MediaWhereInput;
      orderBy?: MediaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MediaConnectionPromise;
  metaType: (where: MetaTypeWhereUniqueInput) => MetaTypeNullablePromise;
  metaTypes: (
    args?: {
      where?: MetaTypeWhereInput;
      orderBy?: MetaTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<MetaType>;
  metaTypesConnection: (
    args?: {
      where?: MetaTypeWhereInput;
      orderBy?: MetaTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MetaTypeConnectionPromise;
  name: (where: NameWhereUniqueInput) => NameNullablePromise;
  names: (
    args?: {
      where?: NameWhereInput;
      orderBy?: NameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Name>;
  namesConnection: (
    args?: {
      where?: NameWhereInput;
      orderBy?: NameOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NameConnectionPromise;
  policy: (where: PolicyWhereUniqueInput) => PolicyNullablePromise;
  policies: (
    args?: {
      where?: PolicyWhereInput;
      orderBy?: PolicyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Policy>;
  policiesConnection: (
    args?: {
      where?: PolicyWhereInput;
      orderBy?: PolicyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PolicyConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfileNullablePromise;
  profiles: (
    args?: {
      where?: ProfileWhereInput;
      orderBy?: ProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Profile>;
  profilesConnection: (
    args?: {
      where?: ProfileWhereInput;
      orderBy?: ProfileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProfileConnectionPromise;
  sizeType: (where: SizeTypeWhereUniqueInput) => SizeTypeNullablePromise;
  sizeTypes: (
    args?: {
      where?: SizeTypeWhereInput;
      orderBy?: SizeTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SizeType>;
  sizeTypesConnection: (
    args?: {
      where?: SizeTypeWhereInput;
      orderBy?: SizeTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SizeTypeConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBirth: (data: BirthCreateInput) => BirthPromise;
  updateBirth: (
    args: {
      data: BirthUpdateInput;
      where: BirthWhereUniqueInput;
    }
  ) => BirthPromise;
  updateManyBirths: (
    args: {
      data: BirthUpdateManyMutationInput;
      where?: BirthWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertBirth: (
    args: {
      where: BirthWhereUniqueInput;
      create: BirthCreateInput;
      update: BirthUpdateInput;
    }
  ) => BirthPromise;
  deleteBirth: (where: BirthWhereUniqueInput) => BirthPromise;
  deleteManyBirths: (where?: BirthWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (
    args: {
      data: ContactUpdateInput;
      where: ContactWhereUniqueInput;
    }
  ) => ContactPromise;
  updateManyContacts: (
    args: {
      data: ContactUpdateManyMutationInput;
      where?: ContactWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertContact: (
    args: {
      where: ContactWhereUniqueInput;
      create: ContactCreateInput;
      update: ContactUpdateInput;
    }
  ) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (
    args: {
      data: EmployeeUpdateInput;
      where: EmployeeWhereUniqueInput;
    }
  ) => EmployeePromise;
  upsertEmployee: (
    args: {
      where: EmployeeWhereUniqueInput;
      create: EmployeeCreateInput;
      update: EmployeeUpdateInput;
    }
  ) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createInsight: (data: InsightCreateInput) => InsightPromise;
  updateInsight: (
    args: {
      data: InsightUpdateInput;
      where: InsightWhereUniqueInput;
    }
  ) => InsightPromise;
  updateManyInsights: (
    args: {
      data: InsightUpdateManyMutationInput;
      where?: InsightWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertInsight: (
    args: {
      where: InsightWhereUniqueInput;
      create: InsightCreateInput;
      update: InsightUpdateInput;
    }
  ) => InsightPromise;
  deleteInsight: (where: InsightWhereUniqueInput) => InsightPromise;
  deleteManyInsights: (where?: InsightWhereInput) => BatchPayloadPromise;
  createMedia: (data: MediaCreateInput) => MediaPromise;
  updateMedia: (
    args: {
      data: MediaUpdateInput;
      where: MediaWhereUniqueInput;
    }
  ) => MediaPromise;
  updateManyMedias: (
    args: {
      data: MediaUpdateManyMutationInput;
      where?: MediaWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMedia: (
    args: {
      where: MediaWhereUniqueInput;
      create: MediaCreateInput;
      update: MediaUpdateInput;
    }
  ) => MediaPromise;
  deleteMedia: (where: MediaWhereUniqueInput) => MediaPromise;
  deleteManyMedias: (where?: MediaWhereInput) => BatchPayloadPromise;
  createMetaType: (data: MetaTypeCreateInput) => MetaTypePromise;
  updateMetaType: (
    args: {
      data: MetaTypeUpdateInput;
      where: MetaTypeWhereUniqueInput;
    }
  ) => MetaTypePromise;
  updateManyMetaTypes: (
    args: {
      data: MetaTypeUpdateManyMutationInput;
      where?: MetaTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertMetaType: (
    args: {
      where: MetaTypeWhereUniqueInput;
      create: MetaTypeCreateInput;
      update: MetaTypeUpdateInput;
    }
  ) => MetaTypePromise;
  deleteMetaType: (where: MetaTypeWhereUniqueInput) => MetaTypePromise;
  deleteManyMetaTypes: (where?: MetaTypeWhereInput) => BatchPayloadPromise;
  createName: (data: NameCreateInput) => NamePromise;
  updateName: (
    args: {
      data: NameUpdateInput;
      where: NameWhereUniqueInput;
    }
  ) => NamePromise;
  updateManyNames: (
    args: {
      data: NameUpdateManyMutationInput;
      where?: NameWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertName: (
    args: {
      where: NameWhereUniqueInput;
      create: NameCreateInput;
      update: NameUpdateInput;
    }
  ) => NamePromise;
  deleteName: (where: NameWhereUniqueInput) => NamePromise;
  deleteManyNames: (where?: NameWhereInput) => BatchPayloadPromise;
  createPolicy: (data: PolicyCreateInput) => PolicyPromise;
  updatePolicy: (
    args: {
      data: PolicyUpdateInput;
      where: PolicyWhereUniqueInput;
    }
  ) => PolicyPromise;
  updateManyPolicies: (
    args: {
      data: PolicyUpdateManyMutationInput;
      where?: PolicyWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPolicy: (
    args: {
      where: PolicyWhereUniqueInput;
      create: PolicyCreateInput;
      update: PolicyUpdateInput;
    }
  ) => PolicyPromise;
  deletePolicy: (where: PolicyWhereUniqueInput) => PolicyPromise;
  deleteManyPolicies: (where?: PolicyWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: {
      data: PostUpdateInput;
      where: PostWhereUniqueInput;
    }
  ) => PostPromise;
  updateManyPosts: (
    args: {
      data: PostUpdateManyMutationInput;
      where?: PostWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (
    args: {
      data: ProfileUpdateInput;
      where: ProfileWhereUniqueInput;
    }
  ) => ProfilePromise;
  updateManyProfiles: (
    args: {
      data: ProfileUpdateManyMutationInput;
      where?: ProfileWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProfile: (
    args: {
      where: ProfileWhereUniqueInput;
      create: ProfileCreateInput;
      update: ProfileUpdateInput;
    }
  ) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createSizeType: (data: SizeTypeCreateInput) => SizeTypePromise;
  updateSizeType: (
    args: {
      data: SizeTypeUpdateInput;
      where: SizeTypeWhereUniqueInput;
    }
  ) => SizeTypePromise;
  updateManySizeTypes: (
    args: {
      data: SizeTypeUpdateManyMutationInput;
      where?: SizeTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSizeType: (
    args: {
      where: SizeTypeWhereUniqueInput;
      create: SizeTypeCreateInput;
      update: SizeTypeUpdateInput;
    }
  ) => SizeTypePromise;
  deleteSizeType: (where: SizeTypeWhereUniqueInput) => SizeTypePromise;
  deleteManySizeTypes: (where?: SizeTypeWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: {
      data: UserUpdateInput;
      where: UserWhereUniqueInput;
    }
  ) => UserPromise;
  updateManyUsers: (
    args: {
      data: UserUpdateManyMutationInput;
      where?: UserWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  birth: (
    where?: BirthSubscriptionWhereInput
  ) => BirthSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  insight: (
    where?: InsightSubscriptionWhereInput
  ) => InsightSubscriptionPayloadSubscription;
  media: (
    where?: MediaSubscriptionWhereInput
  ) => MediaSubscriptionPayloadSubscription;
  metaType: (
    where?: MetaTypeSubscriptionWhereInput
  ) => MetaTypeSubscriptionPayloadSubscription;
  name: (where?: NameSubscriptionWhereInput) => NameSubscriptionPayloadSubscription;
  policy: (
    where?: PolicySubscriptionWhereInput
  ) => PolicySubscriptionPayloadSubscription;
  post: (where?: PostSubscriptionWhereInput) => PostSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  sizeType: (
    where?: SizeTypeSubscriptionWhereInput
  ) => SizeTypeSubscriptionPayloadSubscription;
  user: (where?: UserSubscriptionWhereInput) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PolicyOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'publishedAt_ASC'
  | 'publishedAt_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'title_ASC'
  | 'title_DESC';

export type ContactOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'address_ASC'
  | 'address_DESC'
  | 'city_ASC'
  | 'city_DESC'
  | 'phone_ASC'
  | 'phone_DESC'
  | 'state_ASC'
  | 'state_DESC';

export type NameOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'first_ASC'
  | 'first_DESC'
  | 'middle_ASC'
  | 'middle_DESC'
  | 'last_ASC'
  | 'last_DESC'
  | 'preferred_ASC'
  | 'preferred_DESC';

export type UserOrderByInput = 'id_ASC' | 'id_DESC' | 'name_ASC' | 'name_DESC';

export type MetaTypeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'featured_ASC'
  | 'featured_DESC';

export type ProfileOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'bio_ASC'
  | 'bio_DESC'
  | 'level_ASC'
  | 'level_DESC'
  | 'title_ASC'
  | 'title_DESC';

export type MediaType = 'Image' | 'Video';

export type EmployeeOrderByInput = 'id_ASC' | 'id_DESC';

export type InsightOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'publishedAt_ASC'
  | 'publishedAt_DESC'
  | 'authorId_ASC'
  | 'authorId_DESC'
  | 'category_ASC'
  | 'category_DESC'
  | 'content_ASC'
  | 'content_DESC'
  | 'desc_ASC'
  | 'desc_DESC'
  | 'title_ASC'
  | 'title_DESC';

export type MediaOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'height_ASC'
  | 'height_DESC'
  | 'source_ASC'
  | 'source_DESC'
  | 'type_ASC'
  | 'type_DESC';

export type BirthOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'address_ASC'
  | 'address_DESC'
  | 'city_ASC'
  | 'city_DESC'
  | 'date_ASC'
  | 'date_DESC'
  | 'state_ASC'
  | 'state_DESC';

export type SizeTypeOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'xs_ASC'
  | 'xs_DESC'
  | 'sm_ASC'
  | 'sm_DESC'
  | 'md_ASC'
  | 'md_DESC'
  | 'lg_ASC'
  | 'lg_DESC'
  | 'xl_ASC'
  | 'xl_DESC';

export type MutationType = 'CREATED' | 'UPDATED' | 'DELETED';

export type PostOrderByInput =
  | 'id_ASC'
  | 'id_DESC'
  | 'createdAt_ASC'
  | 'createdAt_DESC'
  | 'updatedAt_ASC'
  | 'updatedAt_DESC'
  | 'description_ASC'
  | 'description_DESC'
  | 'imageUrl_ASC'
  | 'imageUrl_DESC';

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
}

export type BirthWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProfileCreateOneInput {
  create?: Maybe<ProfileCreateInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactUpdateDataInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
}

export interface MetaTypeUpsertNestedInput {
  update: MetaTypeUpdateDataInput;
  create: MetaTypeCreateInput;
}

export interface ProfileCreateInput {
  id?: Maybe<ID_Input>;
  bio: String;
  level?: Maybe<Int>;
  media?: Maybe<MediaCreateOneInput>;
  title: String;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  imageUrl?: Maybe<String>;
  imageUrl_not?: Maybe<String>;
  imageUrl_in?: Maybe<String[] | String>;
  imageUrl_not_in?: Maybe<String[] | String>;
  imageUrl_lt?: Maybe<String>;
  imageUrl_lte?: Maybe<String>;
  imageUrl_gt?: Maybe<String>;
  imageUrl_gte?: Maybe<String>;
  imageUrl_contains?: Maybe<String>;
  imageUrl_not_contains?: Maybe<String>;
  imageUrl_starts_with?: Maybe<String>;
  imageUrl_not_starts_with?: Maybe<String>;
  imageUrl_ends_with?: Maybe<String>;
  imageUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface SizeTypeUpsertNestedInput {
  update: SizeTypeUpdateDataInput;
  create: SizeTypeCreateInput;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProfileWhereInput>;
  AND?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  OR?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  NOT?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
}

export interface SizeTypeUpdateDataInput {
  xs?: Maybe<Int>;
  sm?: Maybe<Int>;
  md?: Maybe<Int>;
  lg?: Maybe<Int>;
  xl?: Maybe<Int>;
}

export interface PolicySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PolicyWhereInput>;
  AND?: Maybe<PolicySubscriptionWhereInput[] | PolicySubscriptionWhereInput>;
  OR?: Maybe<PolicySubscriptionWhereInput[] | PolicySubscriptionWhereInput>;
  NOT?: Maybe<PolicySubscriptionWhereInput[] | PolicySubscriptionWhereInput>;
}

export interface SizeTypeUpdateOneInput {
  create?: Maybe<SizeTypeCreateInput>;
  update?: Maybe<SizeTypeUpdateDataInput>;
  upsert?: Maybe<SizeTypeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SizeTypeWhereUniqueInput>;
}

export interface NameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  first?: Maybe<String>;
  first_not?: Maybe<String>;
  first_in?: Maybe<String[] | String>;
  first_not_in?: Maybe<String[] | String>;
  first_lt?: Maybe<String>;
  first_lte?: Maybe<String>;
  first_gt?: Maybe<String>;
  first_gte?: Maybe<String>;
  first_contains?: Maybe<String>;
  first_not_contains?: Maybe<String>;
  first_starts_with?: Maybe<String>;
  first_not_starts_with?: Maybe<String>;
  first_ends_with?: Maybe<String>;
  first_not_ends_with?: Maybe<String>;
  middle?: Maybe<String>;
  middle_not?: Maybe<String>;
  middle_in?: Maybe<String[] | String>;
  middle_not_in?: Maybe<String[] | String>;
  middle_lt?: Maybe<String>;
  middle_lte?: Maybe<String>;
  middle_gt?: Maybe<String>;
  middle_gte?: Maybe<String>;
  middle_contains?: Maybe<String>;
  middle_not_contains?: Maybe<String>;
  middle_starts_with?: Maybe<String>;
  middle_not_starts_with?: Maybe<String>;
  middle_ends_with?: Maybe<String>;
  middle_not_ends_with?: Maybe<String>;
  last?: Maybe<String>;
  last_not?: Maybe<String>;
  last_in?: Maybe<String[] | String>;
  last_not_in?: Maybe<String[] | String>;
  last_lt?: Maybe<String>;
  last_lte?: Maybe<String>;
  last_gt?: Maybe<String>;
  last_gte?: Maybe<String>;
  last_contains?: Maybe<String>;
  last_not_contains?: Maybe<String>;
  last_starts_with?: Maybe<String>;
  last_not_starts_with?: Maybe<String>;
  last_ends_with?: Maybe<String>;
  last_not_ends_with?: Maybe<String>;
  preferred?: Maybe<String>;
  preferred_not?: Maybe<String>;
  preferred_in?: Maybe<String[] | String>;
  preferred_not_in?: Maybe<String[] | String>;
  preferred_lt?: Maybe<String>;
  preferred_lte?: Maybe<String>;
  preferred_gt?: Maybe<String>;
  preferred_gte?: Maybe<String>;
  preferred_contains?: Maybe<String>;
  preferred_not_contains?: Maybe<String>;
  preferred_starts_with?: Maybe<String>;
  preferred_not_starts_with?: Maybe<String>;
  preferred_ends_with?: Maybe<String>;
  preferred_not_ends_with?: Maybe<String>;
  AND?: Maybe<NameWhereInput[] | NameWhereInput>;
  OR?: Maybe<NameWhereInput[] | NameWhereInput>;
  NOT?: Maybe<NameWhereInput[] | NameWhereInput>;
}

export interface MetaTypeUpdateDataInput {
  featured?: Maybe<Boolean>;
  size?: Maybe<SizeTypeUpdateOneInput>;
}

export interface MediaWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  type?: Maybe<MediaType>;
  type_not?: Maybe<MediaType>;
  type_in?: Maybe<MediaType[] | MediaType>;
  type_not_in?: Maybe<MediaType[] | MediaType>;
  AND?: Maybe<MediaWhereInput[] | MediaWhereInput>;
  OR?: Maybe<MediaWhereInput[] | MediaWhereInput>;
  NOT?: Maybe<MediaWhereInput[] | MediaWhereInput>;
}

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NameWhereInput>;
  AND?: Maybe<NameSubscriptionWhereInput[] | NameSubscriptionWhereInput>;
  OR?: Maybe<NameSubscriptionWhereInput[] | NameSubscriptionWhereInput>;
  NOT?: Maybe<NameSubscriptionWhereInput[] | NameSubscriptionWhereInput>;
}

export interface BirthWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  address?: Maybe<String>;
  address_not?: Maybe<String>;
  address_in?: Maybe<String[] | String>;
  address_not_in?: Maybe<String[] | String>;
  address_lt?: Maybe<String>;
  address_lte?: Maybe<String>;
  address_gt?: Maybe<String>;
  address_gte?: Maybe<String>;
  address_contains?: Maybe<String>;
  address_not_contains?: Maybe<String>;
  address_starts_with?: Maybe<String>;
  address_not_starts_with?: Maybe<String>;
  address_ends_with?: Maybe<String>;
  address_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  AND?: Maybe<BirthWhereInput[] | BirthWhereInput>;
  OR?: Maybe<BirthWhereInput[] | BirthWhereInput>;
  NOT?: Maybe<BirthWhereInput[] | BirthWhereInput>;
}

export interface MediaSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MediaWhereInput>;
  AND?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
  OR?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
  NOT?: Maybe<MediaSubscriptionWhereInput[] | MediaSubscriptionWhereInput>;
}

export interface MetaTypeUpdateOneInput {
  create?: Maybe<MetaTypeCreateInput>;
  update?: Maybe<MetaTypeUpdateDataInput>;
  upsert?: Maybe<MetaTypeUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MetaTypeWhereUniqueInput>;
}

export interface InsightSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InsightWhereInput>;
  AND?: Maybe<InsightSubscriptionWhereInput[] | InsightSubscriptionWhereInput>;
  OR?: Maybe<InsightSubscriptionWhereInput[] | InsightSubscriptionWhereInput>;
  NOT?: Maybe<InsightSubscriptionWhereInput[] | InsightSubscriptionWhereInput>;
}

export interface InsightUpdateInput {
  publishedAt?: Maybe<DateTimeInput>;
  authorId?: Maybe<String>;
  category?: Maybe<String>;
  content?: Maybe<String>;
  desc?: Maybe<String>;
  media?: Maybe<MediaUpdateOneInput>;
  meta?: Maybe<MetaTypeUpdateOneInput>;
  title?: Maybe<String>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface SizeTypeCreateInput {
  id?: Maybe<ID_Input>;
  xs?: Maybe<Int>;
  sm?: Maybe<Int>;
  md?: Maybe<Int>;
  lg?: Maybe<Int>;
  xl?: Maybe<Int>;
}

export interface MetaTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  featured?: Maybe<Boolean>;
  featured_not?: Maybe<Boolean>;
  size?: Maybe<SizeTypeWhereInput>;
  AND?: Maybe<MetaTypeWhereInput[] | MetaTypeWhereInput>;
  OR?: Maybe<MetaTypeWhereInput[] | MetaTypeWhereInput>;
  NOT?: Maybe<MetaTypeWhereInput[] | MetaTypeWhereInput>;
}

export type SizeTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BirthSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BirthWhereInput>;
  AND?: Maybe<BirthSubscriptionWhereInput[] | BirthSubscriptionWhereInput>;
  OR?: Maybe<BirthSubscriptionWhereInput[] | BirthSubscriptionWhereInput>;
  NOT?: Maybe<BirthSubscriptionWhereInput[] | BirthSubscriptionWhereInput>;
}

export interface SizeTypeCreateOneInput {
  create?: Maybe<SizeTypeCreateInput>;
  connect?: Maybe<SizeTypeWhereUniqueInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
}

export interface MetaTypeCreateInput {
  id?: Maybe<ID_Input>;
  featured?: Maybe<Boolean>;
  size?: Maybe<SizeTypeCreateOneInput>;
}

export type MediaWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MetaTypeCreateOneInput {
  create?: Maybe<MetaTypeCreateInput>;
  connect?: Maybe<MetaTypeWhereUniqueInput>;
}

export interface SizeTypeUpdateInput {
  xs?: Maybe<Int>;
  sm?: Maybe<Int>;
  md?: Maybe<Int>;
  lg?: Maybe<Int>;
  xl?: Maybe<Int>;
}

export interface InsightCreateInput {
  id?: Maybe<ID_Input>;
  publishedAt?: Maybe<DateTimeInput>;
  authorId: String;
  category: String;
  content: String;
  desc: String;
  media?: Maybe<MediaCreateOneInput>;
  meta?: Maybe<MetaTypeCreateOneInput>;
  title: String;
}

export interface ProfileUpdateInput {
  bio?: Maybe<String>;
  level?: Maybe<Int>;
  media?: Maybe<MediaUpdateOneInput>;
  title?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PostUpdateManyMutationInput {
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
}

export interface ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput;
  create: ProfileCreateInput;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  description: String;
  imageUrl: String;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export type NameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface MediaUpsertNestedInput {
  update: MediaUpdateDataInput;
  create: MediaCreateInput;
}

export interface PolicyCreateInput {
  id?: Maybe<ID_Input>;
  publishedAt?: Maybe<DateTimeInput>;
  content: String;
  title: String;
}

export interface MediaUpdateDataInput {
  height?: Maybe<Int>;
  source?: Maybe<String>;
  type?: Maybe<MediaType>;
}

export interface NameUpdateInput {
  first?: Maybe<String>;
  middle?: Maybe<String>;
  last?: Maybe<String>;
  preferred?: Maybe<String>;
}

export interface MediaUpdateOneInput {
  create?: Maybe<MediaCreateInput>;
  update?: Maybe<MediaUpdateDataInput>;
  upsert?: Maybe<MediaUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<MediaWhereUniqueInput>;
}

export interface MetaTypeUpdateManyMutationInput {
  featured?: Maybe<Boolean>;
}

export interface ProfileUpdateDataInput {
  bio?: Maybe<String>;
  level?: Maybe<Int>;
  media?: Maybe<MediaUpdateOneInput>;
  title?: Maybe<String>;
}

export interface MetaTypeUpdateInput {
  featured?: Maybe<Boolean>;
  size?: Maybe<SizeTypeUpdateOneInput>;
}

export interface MediaUpdateInput {
  height?: Maybe<Int>;
  source?: Maybe<String>;
  type?: Maybe<MediaType>;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BirthCreateInput {
  id?: Maybe<ID_Input>;
  address?: Maybe<String>;
  city?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface BirthUpdateInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
}

export interface ProfileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  level?: Maybe<Int>;
  level_not?: Maybe<Int>;
  level_in?: Maybe<Int[] | Int>;
  level_not_in?: Maybe<Int[] | Int>;
  level_lt?: Maybe<Int>;
  level_lte?: Maybe<Int>;
  level_gt?: Maybe<Int>;
  level_gte?: Maybe<Int>;
  media?: Maybe<MediaWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  OR?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  NOT?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
}

export interface BirthUpdateManyMutationInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
}

export interface MetaTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MetaTypeWhereInput>;
  AND?: Maybe<MetaTypeSubscriptionWhereInput[] | MetaTypeSubscriptionWhereInput>;
  OR?: Maybe<MetaTypeSubscriptionWhereInput[] | MetaTypeSubscriptionWhereInput>;
  NOT?: Maybe<MetaTypeSubscriptionWhereInput[] | MetaTypeSubscriptionWhereInput>;
}

export interface ProfileUpdateOneInput {
  create?: Maybe<ProfileCreateInput>;
  update?: Maybe<ProfileUpdateDataInput>;
  upsert?: Maybe<ProfileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EmployeeWhereInput>;
  AND?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  OR?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
  NOT?: Maybe<EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput>;
}

export interface NameUpsertNestedInput {
  update: NameUpdateDataInput;
  create: NameCreateInput;
}

export interface SizeTypeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  xs?: Maybe<Int>;
  xs_not?: Maybe<Int>;
  xs_in?: Maybe<Int[] | Int>;
  xs_not_in?: Maybe<Int[] | Int>;
  xs_lt?: Maybe<Int>;
  xs_lte?: Maybe<Int>;
  xs_gt?: Maybe<Int>;
  xs_gte?: Maybe<Int>;
  sm?: Maybe<Int>;
  sm_not?: Maybe<Int>;
  sm_in?: Maybe<Int[] | Int>;
  sm_not_in?: Maybe<Int[] | Int>;
  sm_lt?: Maybe<Int>;
  sm_lte?: Maybe<Int>;
  sm_gt?: Maybe<Int>;
  sm_gte?: Maybe<Int>;
  md?: Maybe<Int>;
  md_not?: Maybe<Int>;
  md_in?: Maybe<Int[] | Int>;
  md_not_in?: Maybe<Int[] | Int>;
  md_lt?: Maybe<Int>;
  md_lte?: Maybe<Int>;
  md_gt?: Maybe<Int>;
  md_gte?: Maybe<Int>;
  lg?: Maybe<Int>;
  lg_not?: Maybe<Int>;
  lg_in?: Maybe<Int[] | Int>;
  lg_not_in?: Maybe<Int[] | Int>;
  lg_lt?: Maybe<Int>;
  lg_lte?: Maybe<Int>;
  lg_gt?: Maybe<Int>;
  lg_gte?: Maybe<Int>;
  xl?: Maybe<Int>;
  xl_not?: Maybe<Int>;
  xl_in?: Maybe<Int[] | Int>;
  xl_not_in?: Maybe<Int[] | Int>;
  xl_lt?: Maybe<Int>;
  xl_lte?: Maybe<Int>;
  xl_gt?: Maybe<Int>;
  xl_gte?: Maybe<Int>;
  AND?: Maybe<SizeTypeWhereInput[] | SizeTypeWhereInput>;
  OR?: Maybe<SizeTypeWhereInput[] | SizeTypeWhereInput>;
  NOT?: Maybe<SizeTypeWhereInput[] | SizeTypeWhereInput>;
}

export interface NameUpdateDataInput {
  first?: Maybe<String>;
  middle?: Maybe<String>;
  last?: Maybe<String>;
  preferred?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ContactUpdateInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
}

export interface ProfileUpdateManyMutationInput {
  bio?: Maybe<String>;
  level?: Maybe<Int>;
  title?: Maybe<String>;
}

export interface ContactUpdateManyMutationInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  phone?: Maybe<String>;
  state?: Maybe<String>;
}

export interface PostUpdateInput {
  description?: Maybe<String>;
  imageUrl?: Maybe<String>;
}

export interface EmployeeCreateInput {
  id?: Maybe<ID_Input>;
  birth?: Maybe<BirthCreateOneInput>;
  contact?: Maybe<ContactCreateOneInput>;
  name?: Maybe<NameCreateOneInput>;
  profile?: Maybe<ProfileCreateOneInput>;
}

export interface PolicyUpdateInput {
  publishedAt?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  title?: Maybe<String>;
}

export interface BirthCreateOneInput {
  create?: Maybe<BirthCreateInput>;
  connect?: Maybe<BirthWhereUniqueInput>;
}

export type PolicyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactCreateOneInput {
  create?: Maybe<ContactCreateInput>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface MediaUpdateManyMutationInput {
  height?: Maybe<Int>;
  source?: Maybe<String>;
  type?: Maybe<MediaType>;
}

export interface NameCreateOneInput {
  create?: Maybe<NameCreateInput>;
  connect?: Maybe<NameWhereUniqueInput>;
}

export interface SizeTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SizeTypeWhereInput>;
  AND?: Maybe<SizeTypeSubscriptionWhereInput[] | SizeTypeSubscriptionWhereInput>;
  OR?: Maybe<SizeTypeSubscriptionWhereInput[] | SizeTypeSubscriptionWhereInput>;
  NOT?: Maybe<SizeTypeSubscriptionWhereInput[] | SizeTypeSubscriptionWhereInput>;
}

export interface NameCreateInput {
  id?: Maybe<ID_Input>;
  first: String;
  middle?: Maybe<String>;
  last: String;
  preferred?: Maybe<String>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NameUpdateOneInput {
  create?: Maybe<NameCreateInput>;
  update?: Maybe<NameUpdateDataInput>;
  upsert?: Maybe<NameUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NameWhereUniqueInput>;
}

export interface InsightWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  authorId?: Maybe<String>;
  authorId_not?: Maybe<String>;
  authorId_in?: Maybe<String[] | String>;
  authorId_not_in?: Maybe<String[] | String>;
  authorId_lt?: Maybe<String>;
  authorId_lte?: Maybe<String>;
  authorId_gt?: Maybe<String>;
  authorId_gte?: Maybe<String>;
  authorId_contains?: Maybe<String>;
  authorId_not_contains?: Maybe<String>;
  authorId_starts_with?: Maybe<String>;
  authorId_not_starts_with?: Maybe<String>;
  authorId_ends_with?: Maybe<String>;
  authorId_not_ends_with?: Maybe<String>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  desc?: Maybe<String>;
  desc_not?: Maybe<String>;
  desc_in?: Maybe<String[] | String>;
  desc_not_in?: Maybe<String[] | String>;
  desc_lt?: Maybe<String>;
  desc_lte?: Maybe<String>;
  desc_gt?: Maybe<String>;
  desc_gte?: Maybe<String>;
  desc_contains?: Maybe<String>;
  desc_not_contains?: Maybe<String>;
  desc_starts_with?: Maybe<String>;
  desc_not_starts_with?: Maybe<String>;
  desc_ends_with?: Maybe<String>;
  desc_not_ends_with?: Maybe<String>;
  media?: Maybe<MediaWhereInput>;
  meta?: Maybe<MetaTypeWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<InsightWhereInput[] | InsightWhereInput>;
  OR?: Maybe<InsightWhereInput[] | InsightWhereInput>;
  NOT?: Maybe<InsightWhereInput[] | InsightWhereInput>;
}

export interface ContactUpsertNestedInput {
  update: ContactUpdateDataInput;
  create: ContactCreateInput;
}

export interface SizeTypeUpdateManyMutationInput {
  xs?: Maybe<Int>;
  sm?: Maybe<Int>;
  md?: Maybe<Int>;
  lg?: Maybe<Int>;
  xl?: Maybe<Int>;
}

export interface MediaCreateOneInput {
  create?: Maybe<MediaCreateInput>;
  connect?: Maybe<MediaWhereUniqueInput>;
}

export interface PolicyUpdateManyMutationInput {
  publishedAt?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  title?: Maybe<String>;
}

export interface MediaCreateInput {
  id?: Maybe<ID_Input>;
  height?: Maybe<Int>;
  source: String;
  type: MediaType;
}

export interface PolicyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<PolicyWhereInput[] | PolicyWhereInput>;
  OR?: Maybe<PolicyWhereInput[] | PolicyWhereInput>;
  NOT?: Maybe<PolicyWhereInput[] | PolicyWhereInput>;
}

export interface EmployeeUpdateInput {
  birth?: Maybe<BirthUpdateOneInput>;
  contact?: Maybe<ContactUpdateOneInput>;
  name?: Maybe<NameUpdateOneInput>;
  profile?: Maybe<ProfileUpdateOneInput>;
}

export interface EmployeeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  birth?: Maybe<BirthWhereInput>;
  contact?: Maybe<ContactWhereInput>;
  name?: Maybe<NameWhereInput>;
  profile?: Maybe<ProfileWhereInput>;
  AND?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  OR?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
  NOT?: Maybe<EmployeeWhereInput[] | EmployeeWhereInput>;
}

export interface ContactUpdateOneInput {
  create?: Maybe<ContactCreateInput>;
  update?: Maybe<ContactUpdateDataInput>;
  upsert?: Maybe<ContactUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ContactWhereUniqueInput>;
}

export interface BirthUpsertNestedInput {
  update: BirthUpdateDataInput;
  create: BirthCreateInput;
}

export interface BirthUpdateDataInput {
  address?: Maybe<String>;
  city?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
}

export interface BirthUpdateOneInput {
  create?: Maybe<BirthCreateInput>;
  update?: Maybe<BirthUpdateDataInput>;
  upsert?: Maybe<BirthUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BirthWhereUniqueInput>;
}

export type InsightWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InsightUpdateManyMutationInput {
  publishedAt?: Maybe<DateTimeInput>;
  authorId?: Maybe<String>;
  category?: Maybe<String>;
  content?: Maybe<String>;
  desc?: Maybe<String>;
  title?: Maybe<String>;
}

export interface NameUpdateManyMutationInput {
  first?: Maybe<String>;
  middle?: Maybe<String>;
  last?: Maybe<String>;
  preferred?: Maybe<String>;
}

export type MetaTypeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInsight {
  count: Int;
}

export interface AggregateInsightPromise
  extends Promise<AggregateInsight>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInsightSubscription
  extends Promise<AsyncIterator<AggregateInsight>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InsightEdge {
  node: Insight;
  cursor: String;
}

export interface InsightEdgePromise extends Promise<InsightEdge>, Fragmentable {
  node: <T = InsightPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InsightEdgeSubscription
  extends Promise<AsyncIterator<InsightEdge>>,
    Fragmentable {
  node: <T = InsightSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InsightConnection {
  pageInfo: PageInfo;
  edges: InsightEdge[];
}

export interface InsightConnectionPromise
  extends Promise<InsightConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InsightEdge>>() => T;
  aggregate: <T = AggregateInsightPromise>() => T;
}

export interface InsightConnectionSubscription
  extends Promise<AsyncIterator<InsightConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InsightEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInsightSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise extends Promise<BatchPayload>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateBirth {
  count: Int;
}

export interface AggregateBirthPromise
  extends Promise<AggregateBirth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBirthSubscription
  extends Promise<AsyncIterator<AggregateBirth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise extends Promise<AggregateUser>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Name {
  id: ID_Output;
  first: String;
  middle?: String;
  last: String;
  preferred?: String;
}

export interface NamePromise extends Promise<Name>, Fragmentable {
  id: () => Promise<ID_Output>;
  first: () => Promise<String>;
  middle: () => Promise<String>;
  last: () => Promise<String>;
  preferred: () => Promise<String>;
}

export interface NameSubscription
  extends Promise<AsyncIterator<Name>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  first: () => Promise<AsyncIterator<String>>;
  middle: () => Promise<AsyncIterator<String>>;
  last: () => Promise<AsyncIterator<String>>;
  preferred: () => Promise<AsyncIterator<String>>;
}

export interface NameNullablePromise extends Promise<Name | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  first: () => Promise<String>;
  middle: () => Promise<String>;
  last: () => Promise<String>;
  preferred: () => Promise<String>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Birth {
  id: ID_Output;
  address?: String;
  city?: String;
  date?: DateTimeOutput;
  state?: String;
}

export interface BirthPromise extends Promise<Birth>, Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  state: () => Promise<String>;
}

export interface BirthSubscription
  extends Promise<AsyncIterator<Birth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface BirthNullablePromise extends Promise<Birth | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  state: () => Promise<String>;
}

export interface User {
  id: ID_Output;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise extends Promise<User | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SizeTypeEdge {
  node: SizeType;
  cursor: String;
}

export interface SizeTypeEdgePromise extends Promise<SizeTypeEdge>, Fragmentable {
  node: <T = SizeTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SizeTypeEdgeSubscription
  extends Promise<AsyncIterator<SizeTypeEdge>>,
    Fragmentable {
  node: <T = SizeTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BirthSubscriptionPayload {
  mutation: MutationType;
  node: Birth;
  updatedFields: String[];
  previousValues: BirthPreviousValues;
}

export interface BirthSubscriptionPayloadPromise
  extends Promise<BirthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BirthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BirthPreviousValuesPromise>() => T;
}

export interface BirthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BirthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BirthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BirthPreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface BirthPreviousValues {
  id: ID_Output;
  address?: String;
  city?: String;
  date?: DateTimeOutput;
  state?: String;
}

export interface BirthPreviousValuesPromise
  extends Promise<BirthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  state: () => Promise<String>;
}

export interface BirthPreviousValuesSubscription
  extends Promise<AsyncIterator<BirthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SizeType {
  id: ID_Output;
  xs?: Int;
  sm?: Int;
  md?: Int;
  lg?: Int;
  xl?: Int;
}

export interface SizeTypePromise extends Promise<SizeType>, Fragmentable {
  id: () => Promise<ID_Output>;
  xs: () => Promise<Int>;
  sm: () => Promise<Int>;
  md: () => Promise<Int>;
  lg: () => Promise<Int>;
  xl: () => Promise<Int>;
}

export interface SizeTypeSubscription
  extends Promise<AsyncIterator<SizeType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  xs: () => Promise<AsyncIterator<Int>>;
  sm: () => Promise<AsyncIterator<Int>>;
  md: () => Promise<AsyncIterator<Int>>;
  lg: () => Promise<AsyncIterator<Int>>;
  xl: () => Promise<AsyncIterator<Int>>;
}

export interface SizeTypeNullablePromise
  extends Promise<SizeType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  xs: () => Promise<Int>;
  sm: () => Promise<Int>;
  md: () => Promise<Int>;
  lg: () => Promise<Int>;
  xl: () => Promise<Int>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise extends Promise<AggregatePost>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface ContactPreviousValues {
  id: ID_Output;
  address?: String;
  city?: String;
  phone?: String;
  state?: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  phone: () => Promise<String>;
  state: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  imageUrl: String;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  imageUrl: () => Promise<String>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
}

export interface PostNullablePromise extends Promise<Post | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  imageUrl: () => Promise<String>;
}

export interface MetaType {
  id: ID_Output;
  featured?: Boolean;
}

export interface MetaTypePromise extends Promise<MetaType>, Fragmentable {
  id: () => Promise<ID_Output>;
  featured: () => Promise<Boolean>;
  size: <T = SizeTypePromise>() => T;
}

export interface MetaTypeSubscription
  extends Promise<AsyncIterator<MetaType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
  size: <T = SizeTypeSubscription>() => T;
}

export interface MetaTypeNullablePromise
  extends Promise<MetaType | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  featured: () => Promise<Boolean>;
  size: <T = SizeTypePromise>() => T;
}

export interface PolicyEdge {
  node: Policy;
  cursor: String;
}

export interface PolicyEdgePromise extends Promise<PolicyEdge>, Fragmentable {
  node: <T = PolicyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PolicyEdgeSubscription
  extends Promise<AsyncIterator<PolicyEdge>>,
    Fragmentable {
  node: <T = PolicySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  node: Employee;
  updatedFields: String[];
  previousValues: EmployeePreviousValues;
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EmployeePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValuesPromise>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface BirthConnection {
  pageInfo: PageInfo;
  edges: BirthEdge[];
}

export interface BirthConnectionPromise
  extends Promise<BirthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BirthEdge>>() => T;
  aggregate: <T = AggregateBirthPromise>() => T;
}

export interface BirthConnectionSubscription
  extends Promise<AsyncIterator<BirthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BirthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBirthSubscription>() => T;
}

export interface EmployeePreviousValues {
  id: ID_Output;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateName {
  count: Int;
}

export interface AggregateNamePromise extends Promise<AggregateName>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNameSubscription
  extends Promise<AsyncIterator<AggregateName>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Insight {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publishedAt?: DateTimeOutput;
  authorId: String;
  category: String;
  content: String;
  desc: String;
  title: String;
}

export interface InsightPromise extends Promise<Insight>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  authorId: () => Promise<String>;
  category: () => Promise<String>;
  content: () => Promise<String>;
  desc: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  meta: <T = MetaTypePromise>() => T;
  title: () => Promise<String>;
}

export interface InsightSubscription
  extends Promise<AsyncIterator<Insight>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  authorId: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  media: <T = MediaSubscription>() => T;
  meta: <T = MetaTypeSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
}

export interface InsightNullablePromise
  extends Promise<Insight | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  authorId: () => Promise<String>;
  category: () => Promise<String>;
  content: () => Promise<String>;
  desc: () => Promise<String>;
  media: <T = MediaPromise>() => T;
  meta: <T = MetaTypePromise>() => T;
  title: () => Promise<String>;
}

export interface NameConnection {
  pageInfo: PageInfo;
  edges: NameEdge[];
}

export interface NameConnectionPromise
  extends Promise<NameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NameEdge>>() => T;
  aggregate: <T = AggregateNamePromise>() => T;
}

export interface NameConnectionSubscription
  extends Promise<AsyncIterator<NameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNameSubscription>() => T;
}

export interface InsightSubscriptionPayload {
  mutation: MutationType;
  node: Insight;
  updatedFields: String[];
  previousValues: InsightPreviousValues;
}

export interface InsightSubscriptionPayloadPromise
  extends Promise<InsightSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InsightPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InsightPreviousValuesPromise>() => T;
}

export interface InsightSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InsightSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InsightSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InsightPreviousValuesSubscription>() => T;
}

export interface AggregateMetaType {
  count: Int;
}

export interface AggregateMetaTypePromise
  extends Promise<AggregateMetaType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMetaTypeSubscription
  extends Promise<AsyncIterator<AggregateMetaType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InsightPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publishedAt?: DateTimeOutput;
  authorId: String;
  category: String;
  content: String;
  desc: String;
  title: String;
}

export interface InsightPreviousValuesPromise
  extends Promise<InsightPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  authorId: () => Promise<String>;
  category: () => Promise<String>;
  content: () => Promise<String>;
  desc: () => Promise<String>;
  title: () => Promise<String>;
}

export interface InsightPreviousValuesSubscription
  extends Promise<AsyncIterator<InsightPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  authorId: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  desc: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface MetaTypeConnection {
  pageInfo: PageInfo;
  edges: MetaTypeEdge[];
}

export interface MetaTypeConnectionPromise
  extends Promise<MetaTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MetaTypeEdge>>() => T;
  aggregate: <T = AggregateMetaTypePromise>() => T;
}

export interface MetaTypeConnectionSubscription
  extends Promise<AsyncIterator<MetaTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MetaTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMetaTypeSubscription>() => T;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateMedia {
  count: Int;
}

export interface AggregateMediaPromise
  extends Promise<AggregateMedia>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMediaSubscription
  extends Promise<AsyncIterator<AggregateMedia>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MediaSubscriptionPayload {
  mutation: MutationType;
  node: Media;
  updatedFields: String[];
  previousValues: MediaPreviousValues;
}

export interface MediaSubscriptionPayloadPromise
  extends Promise<MediaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MediaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MediaPreviousValuesPromise>() => T;
}

export interface MediaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MediaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MediaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MediaPreviousValuesSubscription>() => T;
}

export interface MediaConnection {
  pageInfo: PageInfo;
  edges: MediaEdge[];
}

export interface MediaConnectionPromise
  extends Promise<MediaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MediaEdge>>() => T;
  aggregate: <T = AggregateMediaPromise>() => T;
}

export interface MediaConnectionSubscription
  extends Promise<AsyncIterator<MediaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MediaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMediaSubscription>() => T;
}

export interface MediaPreviousValues {
  id: ID_Output;
  height?: Int;
  source: String;
  type: MediaType;
}

export interface MediaPreviousValuesPromise
  extends Promise<MediaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  height: () => Promise<Int>;
  source: () => Promise<String>;
  type: () => Promise<MediaType>;
}

export interface MediaPreviousValuesSubscription
  extends Promise<AsyncIterator<MediaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  height: () => Promise<AsyncIterator<Int>>;
  source: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<MediaType>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface EmployeeEdge {
  node: Employee;
  cursor: String;
}

export interface EmployeeEdgePromise extends Promise<EmployeeEdge>, Fragmentable {
  node: <T = EmployeePromise>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSizeType {
  count: Int;
}

export interface AggregateSizeTypePromise
  extends Promise<AggregateSizeType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSizeTypeSubscription
  extends Promise<AsyncIterator<AggregateSizeType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetaTypeSubscriptionPayload {
  mutation: MutationType;
  node: MetaType;
  updatedFields: String[];
  previousValues: MetaTypePreviousValues;
}

export interface MetaTypeSubscriptionPayloadPromise
  extends Promise<MetaTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MetaTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MetaTypePreviousValuesPromise>() => T;
}

export interface MetaTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MetaTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MetaTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MetaTypePreviousValuesSubscription>() => T;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MetaTypePreviousValues {
  id: ID_Output;
  featured?: Boolean;
}

export interface MetaTypePreviousValuesPromise
  extends Promise<MetaTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  featured: () => Promise<Boolean>;
}

export interface MetaTypePreviousValuesSubscription
  extends Promise<AsyncIterator<MetaTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  featured: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EmployeeConnection {
  pageInfo: PageInfo;
  edges: EmployeeEdge[];
}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployeePromise>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface AggregatePolicy {
  count: Int;
}

export interface AggregatePolicyPromise
  extends Promise<AggregatePolicy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePolicySubscription
  extends Promise<AsyncIterator<AggregatePolicy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NameSubscriptionPayload {
  mutation: MutationType;
  node: Name;
  updatedFields: String[];
  previousValues: NamePreviousValues;
}

export interface NameSubscriptionPayloadPromise
  extends Promise<NameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NamePreviousValuesPromise>() => T;
}

export interface NameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NamePreviousValuesSubscription>() => T;
}

export interface Policy {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  publishedAt?: DateTimeOutput;
  content: String;
  title: String;
}

export interface PolicyPromise extends Promise<Policy>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  title: () => Promise<String>;
}

export interface PolicySubscription
  extends Promise<AsyncIterator<Policy>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface PolicyNullablePromise extends Promise<Policy | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  title: () => Promise<String>;
}

export interface NamePreviousValues {
  id: ID_Output;
  first: String;
  middle?: String;
  last: String;
  preferred?: String;
}

export interface NamePreviousValuesPromise
  extends Promise<NamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  first: () => Promise<String>;
  middle: () => Promise<String>;
  last: () => Promise<String>;
  preferred: () => Promise<String>;
}

export interface NamePreviousValuesSubscription
  extends Promise<AsyncIterator<NamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  first: () => Promise<AsyncIterator<String>>;
  middle: () => Promise<AsyncIterator<String>>;
  last: () => Promise<AsyncIterator<String>>;
  preferred: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Contact {
  id: ID_Output;
  address?: String;
  city?: String;
  phone?: String;
  state?: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  phone: () => Promise<String>;
  state: () => Promise<String>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  city: () => Promise<String>;
  phone: () => Promise<String>;
  state: () => Promise<String>;
}

export interface SizeTypePreviousValues {
  id: ID_Output;
  xs?: Int;
  sm?: Int;
  md?: Int;
  lg?: Int;
  xl?: Int;
}

export interface SizeTypePreviousValuesPromise
  extends Promise<SizeTypePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  xs: () => Promise<Int>;
  sm: () => Promise<Int>;
  md: () => Promise<Int>;
  lg: () => Promise<Int>;
  xl: () => Promise<Int>;
}

export interface SizeTypePreviousValuesSubscription
  extends Promise<AsyncIterator<SizeTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  xs: () => Promise<AsyncIterator<Int>>;
  sm: () => Promise<AsyncIterator<Int>>;
  md: () => Promise<AsyncIterator<Int>>;
  lg: () => Promise<AsyncIterator<Int>>;
  xl: () => Promise<AsyncIterator<Int>>;
}

export interface PolicySubscriptionPayload {
  mutation: MutationType;
  node: Policy;
  updatedFields: String[];
  previousValues: PolicyPreviousValues;
}

export interface PolicySubscriptionPayloadPromise
  extends Promise<PolicySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PolicyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PolicyPreviousValuesPromise>() => T;
}

export interface PolicySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PolicySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PolicySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PolicyPreviousValuesSubscription>() => T;
}

export interface BirthEdge {
  node: Birth;
  cursor: String;
}

export interface BirthEdgePromise extends Promise<BirthEdge>, Fragmentable {
  node: <T = BirthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BirthEdgeSubscription
  extends Promise<AsyncIterator<BirthEdge>>,
    Fragmentable {
  node: <T = BirthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PolicyPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  publishedAt?: DateTimeOutput;
  content: String;
  title: String;
}

export interface PolicyPreviousValuesPromise
  extends Promise<PolicyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  title: () => Promise<String>;
}

export interface PolicyPreviousValuesSubscription
  extends Promise<AsyncIterator<PolicyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface SizeTypeConnection {
  pageInfo: PageInfo;
  edges: SizeTypeEdge[];
}

export interface SizeTypeConnectionPromise
  extends Promise<SizeTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SizeTypeEdge>>() => T;
  aggregate: <T = AggregateSizeTypePromise>() => T;
}

export interface SizeTypeConnectionSubscription
  extends Promise<AsyncIterator<SizeTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SizeTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSizeTypeSubscription>() => T;
}

export interface Media {
  id: ID_Output;
  height?: Int;
  source: String;
  type: MediaType;
}

export interface MediaPromise extends Promise<Media>, Fragmentable {
  id: () => Promise<ID_Output>;
  height: () => Promise<Int>;
  source: () => Promise<String>;
  type: () => Promise<MediaType>;
}

export interface MediaSubscription
  extends Promise<AsyncIterator<Media>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  height: () => Promise<AsyncIterator<Int>>;
  source: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<MediaType>>;
}

export interface MediaNullablePromise extends Promise<Media | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  height: () => Promise<Int>;
  source: () => Promise<String>;
  type: () => Promise<MediaType>;
}

export interface Employee {
  id: ID_Output;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  birth: <T = BirthPromise>() => T;
  contact: <T = ContactPromise>() => T;
  name: <T = NamePromise>() => T;
  profile: <T = ProfilePromise>() => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  birth: <T = BirthSubscription>() => T;
  contact: <T = ContactSubscription>() => T;
  name: <T = NameSubscription>() => T;
  profile: <T = ProfileSubscription>() => T;
}

export interface EmployeeNullablePromise
  extends Promise<Employee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  birth: <T = BirthPromise>() => T;
  contact: <T = ContactPromise>() => T;
  name: <T = NamePromise>() => T;
  profile: <T = ProfilePromise>() => T;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface NameEdge {
  node: Name;
  cursor: String;
}

export interface NameEdgePromise extends Promise<NameEdge>, Fragmentable {
  node: <T = NamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NameEdgeSubscription
  extends Promise<AsyncIterator<NameEdge>>,
    Fragmentable {
  node: <T = NameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MediaEdge {
  node: Media;
  cursor: String;
}

export interface MediaEdgePromise extends Promise<MediaEdge>, Fragmentable {
  node: <T = MediaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MediaEdgeSubscription
  extends Promise<AsyncIterator<MediaEdge>>,
    Fragmentable {
  node: <T = MediaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProfilePreviousValues {
  id: ID_Output;
  bio: String;
  level?: Int;
  title: String;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bio: () => Promise<String>;
  level: () => Promise<Int>;
  title: () => Promise<String>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bio: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Int>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface Profile {
  id: ID_Output;
  bio: String;
  level?: Int;
  title: String;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>;
  bio: () => Promise<String>;
  level: () => Promise<Int>;
  media: <T = MediaPromise>() => T;
  title: () => Promise<String>;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bio: () => Promise<AsyncIterator<String>>;
  level: () => Promise<AsyncIterator<Int>>;
  media: <T = MediaSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
}

export interface ProfileNullablePromise
  extends Promise<Profile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bio: () => Promise<String>;
  level: () => Promise<Int>;
  media: <T = MediaPromise>() => T;
  title: () => Promise<String>;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  imageUrl: String;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  imageUrl: () => Promise<String>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  imageUrl: () => Promise<AsyncIterator<String>>;
}

export interface SizeTypeSubscriptionPayload {
  mutation: MutationType;
  node: SizeType;
  updatedFields: String[];
  previousValues: SizeTypePreviousValues;
}

export interface SizeTypeSubscriptionPayloadPromise
  extends Promise<SizeTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SizeTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SizeTypePreviousValuesPromise>() => T;
}

export interface SizeTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SizeTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SizeTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SizeTypePreviousValuesSubscription>() => T;
}

export interface MetaTypeEdge {
  node: MetaType;
  cursor: String;
}

export interface MetaTypeEdgePromise extends Promise<MetaTypeEdge>, Fragmentable {
  node: <T = MetaTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MetaTypeEdgeSubscription
  extends Promise<AsyncIterator<MetaTypeEdge>>,
    Fragmentable {
  node: <T = MetaTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PolicyConnection {
  pageInfo: PageInfo;
  edges: PolicyEdge[];
}

export interface PolicyConnectionPromise
  extends Promise<PolicyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PolicyEdge>>() => T;
  aggregate: <T = AggregatePolicyPromise>() => T;
}

export interface PolicyConnectionSubscription
  extends Promise<AsyncIterator<PolicyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PolicyEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePolicySubscription>() => T;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: 'Name',
    embedded: false,
  },
  {
    name: 'Birth',
    embedded: false,
  },
  {
    name: 'Contact',
    embedded: false,
  },
  {
    name: 'Profile',
    embedded: false,
  },
  {
    name: 'Employee',
    embedded: false,
  },
  {
    name: 'MediaType',
    embedded: false,
  },
  {
    name: 'Media',
    embedded: false,
  },
  {
    name: 'Post',
    embedded: false,
  },
  {
    name: 'SizeType',
    embedded: false,
  },
  {
    name: 'MetaType',
    embedded: false,
  },
  {
    name: 'Insight',
    embedded: false,
  },
  {
    name: 'Policy',
    embedded: false,
  },
  {
    name: 'User',
    embedded: false,
  },
];

/**
 * Type Defs
 */

export const prisma: Prisma;
