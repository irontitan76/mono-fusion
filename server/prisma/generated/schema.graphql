### This file was autogenerated by Nexus 0.11.7
### Do not make changes to this file directly

type AggregateBirth {
  count: Int!
}

type AggregateContact {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateInsight {
  count: Int!
}

type AggregateMedia {
  count: Int!
}

type AggregateMetaType {
  count: Int!
}

type AggregateName {
  count: Int!
}

type AggregatePolicy {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateSizeType {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Birth {
  address: String
  city: String
  date: DateTime
  id: ID!
  state: String
}

type BirthConnection {
  aggregate: AggregateBirth!
  edges: [BirthEdge!]!
  pageInfo: PageInfo!
}

input BirthCreateInput {
  address: String
  city: String
  date: DateTime
  id: ID
  state: String
}

input BirthCreateOneInput {
  connect: BirthWhereUniqueInput
  create: BirthCreateInput
}

type BirthEdge {
  cursor: String!
  node: Birth!
}

enum BirthOrderByInput {
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  createdAt_ASC
  createdAt_DESC
  date_ASC
  date_DESC
  id_ASC
  id_DESC
  state_ASC
  state_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input BirthUpdateDataInput {
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthUpdateInput {
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthUpdateManyMutationInput {
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthUpdateOneInput {
  connect: BirthWhereUniqueInput
  create: BirthCreateInput
  delete: Boolean
  disconnect: Boolean
  update: BirthUpdateDataInput
  upsert: BirthUpsertNestedInput
}

input BirthUpsertNestedInput {
  create: BirthCreateInput!
  update: BirthUpdateDataInput!
}

input BirthWhereInput {
  address: String
  address_contains: String
  address_ends_with: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_ends_with: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_starts_with: String
  AND: [BirthWhereInput!]
  city: String
  city_contains: String
  city_ends_with: String
  city_gt: String
  city_gte: String
  city_in: [String!]
  city_lt: String
  city_lte: String
  city_not: String
  city_not_contains: String
  city_not_ends_with: String
  city_not_in: [String!]
  city_not_starts_with: String
  city_starts_with: String
  date: DateTime
  date_gt: DateTime
  date_gte: DateTime
  date_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_not: DateTime
  date_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [BirthWhereInput!]
  OR: [BirthWhereInput!]
  state: String
  state_contains: String
  state_ends_with: String
  state_gt: String
  state_gte: String
  state_in: [String!]
  state_lt: String
  state_lte: String
  state_not: String
  state_not_contains: String
  state_not_ends_with: String
  state_not_in: [String!]
  state_not_starts_with: String
  state_starts_with: String
}

input BirthWhereUniqueInput {
  id: ID
}

type Contact {
  address: String
  city: String
  id: ID!
  phone: String
  state: String
}

type ContactConnection {
  aggregate: AggregateContact!
  edges: [ContactEdge!]!
  pageInfo: PageInfo!
}

input ContactCreateInput {
  address: String
  city: String
  id: ID
  phone: String
  state: String
}

input ContactCreateOneInput {
  connect: ContactWhereUniqueInput
  create: ContactCreateInput
}

type ContactEdge {
  cursor: String!
  node: Contact!
}

enum ContactOrderByInput {
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  phone_ASC
  phone_DESC
  state_ASC
  state_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ContactUpdateDataInput {
  address: String
  city: String
  phone: String
  state: String
}

input ContactUpdateInput {
  address: String
  city: String
  phone: String
  state: String
}

input ContactUpdateManyMutationInput {
  address: String
  city: String
  phone: String
  state: String
}

input ContactUpdateOneInput {
  connect: ContactWhereUniqueInput
  create: ContactCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ContactUpdateDataInput
  upsert: ContactUpsertNestedInput
}

input ContactUpsertNestedInput {
  create: ContactCreateInput!
  update: ContactUpdateDataInput!
}

input ContactWhereInput {
  address: String
  address_contains: String
  address_ends_with: String
  address_gt: String
  address_gte: String
  address_in: [String!]
  address_lt: String
  address_lte: String
  address_not: String
  address_not_contains: String
  address_not_ends_with: String
  address_not_in: [String!]
  address_not_starts_with: String
  address_starts_with: String
  AND: [ContactWhereInput!]
  city: String
  city_contains: String
  city_ends_with: String
  city_gt: String
  city_gte: String
  city_in: [String!]
  city_lt: String
  city_lte: String
  city_not: String
  city_not_contains: String
  city_not_ends_with: String
  city_not_in: [String!]
  city_not_starts_with: String
  city_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  phone: String
  phone_contains: String
  phone_ends_with: String
  phone_gt: String
  phone_gte: String
  phone_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_not: String
  phone_not_contains: String
  phone_not_ends_with: String
  phone_not_in: [String!]
  phone_not_starts_with: String
  phone_starts_with: String
  state: String
  state_contains: String
  state_ends_with: String
  state_gt: String
  state_gte: String
  state_in: [String!]
  state_lt: String
  state_lte: String
  state_not: String
  state_not_contains: String
  state_not_ends_with: String
  state_not_in: [String!]
  state_not_starts_with: String
  state_starts_with: String
}

input ContactWhereUniqueInput {
  id: ID
}

scalar DateTime

type Employee {
  birth: Birth
  contact: Contact
  id: ID!
  name: Name
  profile: Profile
}

type EmployeeConnection {
  aggregate: AggregateEmployee!
  edges: [EmployeeEdge!]!
  pageInfo: PageInfo!
}

input EmployeeCreateInput {
  birth: BirthCreateOneInput
  contact: ContactCreateOneInput
  id: ID
  name: NameCreateOneInput
  profile: ProfileCreateOneInput
}

type EmployeeEdge {
  cursor: String!
  node: Employee!
}

enum EmployeeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input EmployeeUpdateInput {
  birth: BirthUpdateOneInput
  contact: ContactUpdateOneInput
  name: NameUpdateOneInput
  profile: ProfileUpdateOneInput
}

input EmployeeWhereInput {
  AND: [EmployeeWhereInput!]
  birth: BirthWhereInput
  contact: ContactWhereInput
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: NameWhereInput
  NOT: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  profile: ProfileWhereInput
}

input EmployeeWhereUniqueInput {
  id: ID
}

type Insight {
  authorId: String!
  category: String!
  content: String!
  createdAt: DateTime!
  desc: String!
  id: ID!
  media: Media
  meta: MetaType
  publishedAt: DateTime
  title: String!
  updatedAt: DateTime!
}

type InsightConnection {
  aggregate: AggregateInsight!
  edges: [InsightEdge!]!
  pageInfo: PageInfo!
}

input InsightCreateInput {
  authorId: String!
  category: String!
  content: String!
  desc: String!
  id: ID
  media: MediaCreateOneInput
  meta: MetaTypeCreateOneInput
  publishedAt: DateTime
  title: String!
}

type InsightEdge {
  cursor: String!
  node: Insight!
}

enum InsightOrderByInput {
  authorId_ASC
  authorId_DESC
  category_ASC
  category_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  desc_ASC
  desc_DESC
  id_ASC
  id_DESC
  publishedAt_ASC
  publishedAt_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input InsightUpdateInput {
  authorId: String
  category: String
  content: String
  desc: String
  media: MediaUpdateOneInput
  meta: MetaTypeUpdateOneInput
  publishedAt: DateTime
  title: String
}

input InsightUpdateManyMutationInput {
  authorId: String
  category: String
  content: String
  desc: String
  publishedAt: DateTime
  title: String
}

input InsightWhereInput {
  AND: [InsightWhereInput!]
  authorId: String
  authorId_contains: String
  authorId_ends_with: String
  authorId_gt: String
  authorId_gte: String
  authorId_in: [String!]
  authorId_lt: String
  authorId_lte: String
  authorId_not: String
  authorId_not_contains: String
  authorId_not_ends_with: String
  authorId_not_in: [String!]
  authorId_not_starts_with: String
  authorId_starts_with: String
  category: String
  category_contains: String
  category_ends_with: String
  category_gt: String
  category_gte: String
  category_in: [String!]
  category_lt: String
  category_lte: String
  category_not: String
  category_not_contains: String
  category_not_ends_with: String
  category_not_in: [String!]
  category_not_starts_with: String
  category_starts_with: String
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  desc: String
  desc_contains: String
  desc_ends_with: String
  desc_gt: String
  desc_gte: String
  desc_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_not: String
  desc_not_contains: String
  desc_not_ends_with: String
  desc_not_in: [String!]
  desc_not_starts_with: String
  desc_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  media: MediaWhereInput
  meta: MetaTypeWhereInput
  NOT: [InsightWhereInput!]
  OR: [InsightWhereInput!]
  publishedAt: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_not: DateTime
  publishedAt_not_in: [DateTime!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input InsightWhereUniqueInput {
  id: ID
}

scalar Long

type Media {
  height: Int
  id: ID!
  source: String!
  type: MediaType!
}

type MediaConnection {
  aggregate: AggregateMedia!
  edges: [MediaEdge!]!
  pageInfo: PageInfo!
}

input MediaCreateInput {
  height: Int
  id: ID
  source: String!
  type: MediaType!
}

input MediaCreateOneInput {
  connect: MediaWhereUniqueInput
  create: MediaCreateInput
}

type MediaEdge {
  cursor: String!
  node: Media!
}

enum MediaOrderByInput {
  createdAt_ASC
  createdAt_DESC
  height_ASC
  height_DESC
  id_ASC
  id_DESC
  source_ASC
  source_DESC
  type_ASC
  type_DESC
  updatedAt_ASC
  updatedAt_DESC
}

enum MediaType {
  Image
  Video
}

input MediaUpdateDataInput {
  height: Int
  source: String
  type: MediaType
}

input MediaUpdateInput {
  height: Int
  source: String
  type: MediaType
}

input MediaUpdateManyMutationInput {
  height: Int
  source: String
  type: MediaType
}

input MediaUpdateOneInput {
  connect: MediaWhereUniqueInput
  create: MediaCreateInput
  delete: Boolean
  disconnect: Boolean
  update: MediaUpdateDataInput
  upsert: MediaUpsertNestedInput
}

input MediaUpsertNestedInput {
  create: MediaCreateInput!
  update: MediaUpdateDataInput!
}

input MediaWhereInput {
  AND: [MediaWhereInput!]
  height: Int
  height_gt: Int
  height_gte: Int
  height_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_not: Int
  height_not_in: [Int!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [MediaWhereInput!]
  OR: [MediaWhereInput!]
  source: String
  source_contains: String
  source_ends_with: String
  source_gt: String
  source_gte: String
  source_in: [String!]
  source_lt: String
  source_lte: String
  source_not: String
  source_not_contains: String
  source_not_ends_with: String
  source_not_in: [String!]
  source_not_starts_with: String
  source_starts_with: String
  type: MediaType
  type_in: [MediaType!]
  type_not: MediaType
  type_not_in: [MediaType!]
}

input MediaWhereUniqueInput {
  id: ID
}

type MetaType {
  featured: Boolean
  id: ID!
  size: SizeType
}

type MetaTypeConnection {
  aggregate: AggregateMetaType!
  edges: [MetaTypeEdge!]!
  pageInfo: PageInfo!
}

input MetaTypeCreateInput {
  featured: Boolean
  id: ID
  size: SizeTypeCreateOneInput
}

input MetaTypeCreateOneInput {
  connect: MetaTypeWhereUniqueInput
  create: MetaTypeCreateInput
}

type MetaTypeEdge {
  cursor: String!
  node: MetaType!
}

enum MetaTypeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  featured_ASC
  featured_DESC
  id_ASC
  id_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input MetaTypeUpdateDataInput {
  featured: Boolean
  size: SizeTypeUpdateOneInput
}

input MetaTypeUpdateInput {
  featured: Boolean
  size: SizeTypeUpdateOneInput
}

input MetaTypeUpdateManyMutationInput {
  featured: Boolean
}

input MetaTypeUpdateOneInput {
  connect: MetaTypeWhereUniqueInput
  create: MetaTypeCreateInput
  delete: Boolean
  disconnect: Boolean
  update: MetaTypeUpdateDataInput
  upsert: MetaTypeUpsertNestedInput
}

input MetaTypeUpsertNestedInput {
  create: MetaTypeCreateInput!
  update: MetaTypeUpdateDataInput!
}

input MetaTypeWhereInput {
  AND: [MetaTypeWhereInput!]
  featured: Boolean
  featured_not: Boolean
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [MetaTypeWhereInput!]
  OR: [MetaTypeWhereInput!]
  size: SizeTypeWhereInput
}

input MetaTypeWhereUniqueInput {
  id: ID
}

type Mutation {
  createBirth(data: BirthCreateInput!): Birth!
  createContact(data: ContactCreateInput!): Contact!
  createEmployee(data: EmployeeCreateInput!): Employee!
  createInsight(data: InsightCreateInput!): Insight!
  createMedia(data: MediaCreateInput!): Media!
  createMetaType(data: MetaTypeCreateInput!): MetaType!
  createName(data: NameCreateInput!): Name!
  createPolicy(data: PolicyCreateInput!): Policy!
  createPost(data: PostCreateInput!): Post!
  createProfile(data: ProfileCreateInput!): Profile!
  createSizeType(data: SizeTypeCreateInput!): SizeType!
  createUser(data: UserCreateInput!): User!
  deleteBirth(where: BirthWhereUniqueInput!): Birth
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteInsight(where: InsightWhereUniqueInput!): Insight
  deleteManyBirths(where: BirthWhereInput): BatchPayload!
  deleteManyContacts(where: ContactWhereInput): BatchPayload!
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  deleteManyInsights(where: InsightWhereInput): BatchPayload!
  deleteManyMedias(where: MediaWhereInput): BatchPayload!
  deleteManyMetaTypes(where: MetaTypeWhereInput): BatchPayload!
  deleteManyNames(where: NameWhereInput): BatchPayload!
  deleteManyPolicies(where: PolicyWhereInput): BatchPayload!
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  deleteManySizeTypes(where: SizeTypeWhereInput): BatchPayload!
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  deleteMedia(where: MediaWhereUniqueInput!): Media
  deleteMetaType(where: MetaTypeWhereUniqueInput!): MetaType
  deleteName(where: NameWhereUniqueInput!): Name
  deletePolicy(where: PolicyWhereUniqueInput!): Policy
  deletePost(where: PostWhereUniqueInput!): Post
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteSizeType(where: SizeTypeWhereUniqueInput!): SizeType
  deleteUser(where: UserWhereUniqueInput!): User
  updateBirth(data: BirthUpdateInput!, where: BirthWhereUniqueInput!): Birth
  updateContact(data: ContactUpdateInput!, where: ContactWhereUniqueInput!): Contact
  updateEmployee(
    data: EmployeeUpdateInput!
    where: EmployeeWhereUniqueInput!
  ): Employee
  updateInsight(data: InsightUpdateInput!, where: InsightWhereUniqueInput!): Insight
  updateManyBirths(
    data: BirthUpdateManyMutationInput!
    where: BirthWhereInput
  ): BatchPayload!
  updateManyContacts(
    data: ContactUpdateManyMutationInput!
    where: ContactWhereInput
  ): BatchPayload!
  updateManyInsights(
    data: InsightUpdateManyMutationInput!
    where: InsightWhereInput
  ): BatchPayload!
  updateManyMedias(
    data: MediaUpdateManyMutationInput!
    where: MediaWhereInput
  ): BatchPayload!
  updateManyMetaTypes(
    data: MetaTypeUpdateManyMutationInput!
    where: MetaTypeWhereInput
  ): BatchPayload!
  updateManyNames(
    data: NameUpdateManyMutationInput!
    where: NameWhereInput
  ): BatchPayload!
  updateManyPolicies(
    data: PolicyUpdateManyMutationInput!
    where: PolicyWhereInput
  ): BatchPayload!
  updateManyPosts(
    data: PostUpdateManyMutationInput!
    where: PostWhereInput
  ): BatchPayload!
  updateManyProfiles(
    data: ProfileUpdateManyMutationInput!
    where: ProfileWhereInput
  ): BatchPayload!
  updateManySizeTypes(
    data: SizeTypeUpdateManyMutationInput!
    where: SizeTypeWhereInput
  ): BatchPayload!
  updateManyUsers(
    data: UserUpdateManyMutationInput!
    where: UserWhereInput
  ): BatchPayload!
  updateMedia(data: MediaUpdateInput!, where: MediaWhereUniqueInput!): Media
  updateMetaType(
    data: MetaTypeUpdateInput!
    where: MetaTypeWhereUniqueInput!
  ): MetaType
  updateName(data: NameUpdateInput!, where: NameWhereUniqueInput!): Name
  updatePolicy(data: PolicyUpdateInput!, where: PolicyWhereUniqueInput!): Policy
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateSizeType(
    data: SizeTypeUpdateInput!
    where: SizeTypeWhereUniqueInput!
  ): SizeType
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertBirth(
    create: BirthCreateInput!
    update: BirthUpdateInput!
    where: BirthWhereUniqueInput!
  ): Birth!
  upsertContact(
    create: ContactCreateInput!
    update: ContactUpdateInput!
    where: ContactWhereUniqueInput!
  ): Contact!
  upsertEmployee(
    create: EmployeeCreateInput!
    update: EmployeeUpdateInput!
    where: EmployeeWhereUniqueInput!
  ): Employee!
  upsertInsight(
    create: InsightCreateInput!
    update: InsightUpdateInput!
    where: InsightWhereUniqueInput!
  ): Insight!
  upsertMedia(
    create: MediaCreateInput!
    update: MediaUpdateInput!
    where: MediaWhereUniqueInput!
  ): Media!
  upsertMetaType(
    create: MetaTypeCreateInput!
    update: MetaTypeUpdateInput!
    where: MetaTypeWhereUniqueInput!
  ): MetaType!
  upsertName(
    create: NameCreateInput!
    update: NameUpdateInput!
    where: NameWhereUniqueInput!
  ): Name!
  upsertPolicy(
    create: PolicyCreateInput!
    update: PolicyUpdateInput!
    where: PolicyWhereUniqueInput!
  ): Policy!
  upsertPost(
    create: PostCreateInput!
    update: PostUpdateInput!
    where: PostWhereUniqueInput!
  ): Post!
  upsertProfile(
    create: ProfileCreateInput!
    update: ProfileUpdateInput!
    where: ProfileWhereUniqueInput!
  ): Profile!
  upsertSizeType(
    create: SizeTypeCreateInput!
    update: SizeTypeUpdateInput!
    where: SizeTypeWhereUniqueInput!
  ): SizeType!
  upsertUser(
    create: UserCreateInput!
    update: UserUpdateInput!
    where: UserWhereUniqueInput!
  ): User!
}

type Name {
  first: String!
  id: ID!
  last: String!
  middle: String
  preferred: String
}

type NameConnection {
  aggregate: AggregateName!
  edges: [NameEdge!]!
  pageInfo: PageInfo!
}

input NameCreateInput {
  first: String!
  id: ID
  last: String!
  middle: String
  preferred: String
}

input NameCreateOneInput {
  connect: NameWhereUniqueInput
  create: NameCreateInput
}

type NameEdge {
  cursor: String!
  node: Name!
}

enum NameOrderByInput {
  createdAt_ASC
  createdAt_DESC
  first_ASC
  first_DESC
  id_ASC
  id_DESC
  last_ASC
  last_DESC
  middle_ASC
  middle_DESC
  preferred_ASC
  preferred_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input NameUpdateDataInput {
  first: String
  last: String
  middle: String
  preferred: String
}

input NameUpdateInput {
  first: String
  last: String
  middle: String
  preferred: String
}

input NameUpdateManyMutationInput {
  first: String
  last: String
  middle: String
  preferred: String
}

input NameUpdateOneInput {
  connect: NameWhereUniqueInput
  create: NameCreateInput
  delete: Boolean
  disconnect: Boolean
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
}

input NameUpsertNestedInput {
  create: NameCreateInput!
  update: NameUpdateDataInput!
}

input NameWhereInput {
  AND: [NameWhereInput!]
  first: String
  first_contains: String
  first_ends_with: String
  first_gt: String
  first_gte: String
  first_in: [String!]
  first_lt: String
  first_lte: String
  first_not: String
  first_not_contains: String
  first_not_ends_with: String
  first_not_in: [String!]
  first_not_starts_with: String
  first_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  last: String
  last_contains: String
  last_ends_with: String
  last_gt: String
  last_gte: String
  last_in: [String!]
  last_lt: String
  last_lte: String
  last_not: String
  last_not_contains: String
  last_not_ends_with: String
  last_not_in: [String!]
  last_not_starts_with: String
  last_starts_with: String
  middle: String
  middle_contains: String
  middle_ends_with: String
  middle_gt: String
  middle_gte: String
  middle_in: [String!]
  middle_lt: String
  middle_lte: String
  middle_not: String
  middle_not_contains: String
  middle_not_ends_with: String
  middle_not_in: [String!]
  middle_not_starts_with: String
  middle_starts_with: String
  NOT: [NameWhereInput!]
  OR: [NameWhereInput!]
  preferred: String
  preferred_contains: String
  preferred_ends_with: String
  preferred_gt: String
  preferred_gte: String
  preferred_in: [String!]
  preferred_lt: String
  preferred_lte: String
  preferred_not: String
  preferred_not_contains: String
  preferred_not_ends_with: String
  preferred_not_in: [String!]
  preferred_not_starts_with: String
  preferred_starts_with: String
}

input NameWhereUniqueInput {
  id: ID
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

type Policy {
  content: String!
  createdAt: DateTime!
  id: ID!
  publishedAt: DateTime
  title: String!
  updatedAt: DateTime
}

type PolicyConnection {
  aggregate: AggregatePolicy!
  edges: [PolicyEdge!]!
  pageInfo: PageInfo!
}

input PolicyCreateInput {
  content: String!
  id: ID
  publishedAt: DateTime
  title: String!
}

type PolicyEdge {
  cursor: String!
  node: Policy!
}

enum PolicyOrderByInput {
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  publishedAt_ASC
  publishedAt_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PolicyUpdateInput {
  content: String
  publishedAt: DateTime
  title: String
}

input PolicyUpdateManyMutationInput {
  content: String
  publishedAt: DateTime
  title: String
}

input PolicyWhereInput {
  AND: [PolicyWhereInput!]
  content: String
  content_contains: String
  content_ends_with: String
  content_gt: String
  content_gte: String
  content_in: [String!]
  content_lt: String
  content_lte: String
  content_not: String
  content_not_contains: String
  content_not_ends_with: String
  content_not_in: [String!]
  content_not_starts_with: String
  content_starts_with: String
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  NOT: [PolicyWhereInput!]
  OR: [PolicyWhereInput!]
  publishedAt: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_not: DateTime
  publishedAt_not_in: [DateTime!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PolicyWhereUniqueInput {
  id: ID
}

type Post {
  createdAt: DateTime!
  description: String!
  id: ID!
  imageUrl: String!
  updatedAt: DateTime!
}

type PostConnection {
  aggregate: AggregatePost!
  edges: [PostEdge!]!
  pageInfo: PageInfo!
}

input PostCreateInput {
  description: String!
  id: ID
  imageUrl: String!
}

type PostEdge {
  cursor: String!
  node: Post!
}

enum PostOrderByInput {
  createdAt_ASC
  createdAt_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
  imageUrl_ASC
  imageUrl_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input PostUpdateInput {
  description: String
  imageUrl: String
}

input PostUpdateManyMutationInput {
  description: String
  imageUrl: String
}

input PostWhereInput {
  AND: [PostWhereInput!]
  createdAt: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdAt_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_not: DateTime
  createdAt_not_in: [DateTime!]
  description: String
  description_contains: String
  description_ends_with: String
  description_gt: String
  description_gte: String
  description_in: [String!]
  description_lt: String
  description_lte: String
  description_not: String
  description_not_contains: String
  description_not_ends_with: String
  description_not_in: [String!]
  description_not_starts_with: String
  description_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  imageUrl: String
  imageUrl_contains: String
  imageUrl_ends_with: String
  imageUrl_gt: String
  imageUrl_gte: String
  imageUrl_in: [String!]
  imageUrl_lt: String
  imageUrl_lte: String
  imageUrl_not: String
  imageUrl_not_contains: String
  imageUrl_not_ends_with: String
  imageUrl_not_in: [String!]
  imageUrl_not_starts_with: String
  imageUrl_starts_with: String
  NOT: [PostWhereInput!]
  OR: [PostWhereInput!]
  updatedAt: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_not: DateTime
  updatedAt_not_in: [DateTime!]
}

input PostWhereUniqueInput {
  id: ID
}

type Profile {
  bio: String!
  id: ID!
  level: Int
  media: Media
  title: String!
}

type ProfileConnection {
  aggregate: AggregateProfile!
  edges: [ProfileEdge!]!
  pageInfo: PageInfo!
}

input ProfileCreateInput {
  bio: String!
  id: ID
  level: Int
  media: MediaCreateOneInput
  title: String!
}

input ProfileCreateOneInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateInput
}

type ProfileEdge {
  cursor: String!
  node: Profile!
}

enum ProfileOrderByInput {
  bio_ASC
  bio_DESC
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  level_ASC
  level_DESC
  title_ASC
  title_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input ProfileUpdateDataInput {
  bio: String
  level: Int
  media: MediaUpdateOneInput
  title: String
}

input ProfileUpdateInput {
  bio: String
  level: Int
  media: MediaUpdateOneInput
  title: String
}

input ProfileUpdateManyMutationInput {
  bio: String
  level: Int
  title: String
}

input ProfileUpdateOneInput {
  connect: ProfileWhereUniqueInput
  create: ProfileCreateInput
  delete: Boolean
  disconnect: Boolean
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
}

input ProfileUpsertNestedInput {
  create: ProfileCreateInput!
  update: ProfileUpdateDataInput!
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  bio: String
  bio_contains: String
  bio_ends_with: String
  bio_gt: String
  bio_gte: String
  bio_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_not: String
  bio_not_contains: String
  bio_not_ends_with: String
  bio_not_in: [String!]
  bio_not_starts_with: String
  bio_starts_with: String
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  level: Int
  level_gt: Int
  level_gte: Int
  level_in: [Int!]
  level_lt: Int
  level_lte: Int
  level_not: Int
  level_not_in: [Int!]
  media: MediaWhereInput
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  title: String
  title_contains: String
  title_ends_with: String
  title_gt: String
  title_gte: String
  title_in: [String!]
  title_lt: String
  title_lte: String
  title_not: String
  title_not_contains: String
  title_not_ends_with: String
  title_not_in: [String!]
  title_not_starts_with: String
  title_starts_with: String
}

input ProfileWhereUniqueInput {
  id: ID
}

type Query {
  birth(where: BirthWhereUniqueInput!): Birth
  births(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: BirthOrderByInput
    skip: Int
    where: BirthWhereInput
  ): [Birth!]!
  birthsConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: BirthOrderByInput
    skip: Int
    where: BirthWhereInput
  ): BirthConnection!
  contact(where: ContactWhereUniqueInput!): Contact
  contacts(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ContactOrderByInput
    skip: Int
    where: ContactWhereInput
  ): [Contact!]!
  contactsConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ContactOrderByInput
    skip: Int
    where: ContactWhereInput
  ): ContactConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EmployeeOrderByInput
    skip: Int
    where: EmployeeWhereInput
  ): [Employee!]!
  employeesConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: EmployeeOrderByInput
    skip: Int
    where: EmployeeWhereInput
  ): EmployeeConnection!
  insight(where: InsightWhereUniqueInput!): Insight
  insights(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: InsightOrderByInput
    skip: Int
    where: InsightWhereInput
  ): [Insight!]!
  insightsConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: InsightOrderByInput
    skip: Int
    where: InsightWhereInput
  ): InsightConnection!
  media(where: MediaWhereUniqueInput!): Media
  medias(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MediaOrderByInput
    skip: Int
    where: MediaWhereInput
  ): [Media!]!
  mediasConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MediaOrderByInput
    skip: Int
    where: MediaWhereInput
  ): MediaConnection!
  metaType(where: MetaTypeWhereUniqueInput!): MetaType
  metaTypes(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MetaTypeOrderByInput
    skip: Int
    where: MetaTypeWhereInput
  ): [MetaType!]!
  metaTypesConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: MetaTypeOrderByInput
    skip: Int
    where: MetaTypeWhereInput
  ): MetaTypeConnection!
  name(where: NameWhereUniqueInput!): Name
  names(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: NameOrderByInput
    skip: Int
    where: NameWhereInput
  ): [Name!]!
  namesConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: NameOrderByInput
    skip: Int
    where: NameWhereInput
  ): NameConnection!
  policies(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PolicyOrderByInput
    skip: Int
    where: PolicyWhereInput
  ): [Policy!]!
  policiesConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PolicyOrderByInput
    skip: Int
    where: PolicyWhereInput
  ): PolicyConnection!
  policy(where: PolicyWhereUniqueInput!): Policy
  post(where: PostWhereUniqueInput!): Post
  posts(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostOrderByInput
    skip: Int
    where: PostWhereInput
  ): [Post!]!
  postsConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: PostOrderByInput
    skip: Int
    where: PostWhereInput
  ): PostConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProfileOrderByInput
    skip: Int
    where: ProfileWhereInput
  ): [Profile!]!
  profilesConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: ProfileOrderByInput
    skip: Int
    where: ProfileWhereInput
  ): ProfileConnection!
  sizeType(where: SizeTypeWhereUniqueInput!): SizeType
  sizeTypes(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SizeTypeOrderByInput
    skip: Int
    where: SizeTypeWhereInput
  ): [SizeType!]!
  sizeTypesConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: SizeTypeOrderByInput
    skip: Int
    where: SizeTypeWhereInput
  ): SizeTypeConnection!
  user(where: UserWhereUniqueInput!): User
  users(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserOrderByInput
    skip: Int
    where: UserWhereInput
  ): [User!]!
  usersConnection(
    after: String
    before: String
    first: Int
    last: Int
    orderBy: UserOrderByInput
    skip: Int
    where: UserWhereInput
  ): UserConnection!
}

type SizeType {
  id: ID!
  lg: Int
  md: Int
  sm: Int
  xl: Int
  xs: Int
}

type SizeTypeConnection {
  aggregate: AggregateSizeType!
  edges: [SizeTypeEdge!]!
  pageInfo: PageInfo!
}

input SizeTypeCreateInput {
  id: ID
  lg: Int
  md: Int
  sm: Int
  xl: Int
  xs: Int
}

input SizeTypeCreateOneInput {
  connect: SizeTypeWhereUniqueInput
  create: SizeTypeCreateInput
}

type SizeTypeEdge {
  cursor: String!
  node: SizeType!
}

enum SizeTypeOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  lg_ASC
  lg_DESC
  md_ASC
  md_DESC
  sm_ASC
  sm_DESC
  updatedAt_ASC
  updatedAt_DESC
  xl_ASC
  xl_DESC
  xs_ASC
  xs_DESC
}

input SizeTypeUpdateDataInput {
  lg: Int
  md: Int
  sm: Int
  xl: Int
  xs: Int
}

input SizeTypeUpdateInput {
  lg: Int
  md: Int
  sm: Int
  xl: Int
  xs: Int
}

input SizeTypeUpdateManyMutationInput {
  lg: Int
  md: Int
  sm: Int
  xl: Int
  xs: Int
}

input SizeTypeUpdateOneInput {
  connect: SizeTypeWhereUniqueInput
  create: SizeTypeCreateInput
  delete: Boolean
  disconnect: Boolean
  update: SizeTypeUpdateDataInput
  upsert: SizeTypeUpsertNestedInput
}

input SizeTypeUpsertNestedInput {
  create: SizeTypeCreateInput!
  update: SizeTypeUpdateDataInput!
}

input SizeTypeWhereInput {
  AND: [SizeTypeWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  lg: Int
  lg_gt: Int
  lg_gte: Int
  lg_in: [Int!]
  lg_lt: Int
  lg_lte: Int
  lg_not: Int
  lg_not_in: [Int!]
  md: Int
  md_gt: Int
  md_gte: Int
  md_in: [Int!]
  md_lt: Int
  md_lte: Int
  md_not: Int
  md_not_in: [Int!]
  NOT: [SizeTypeWhereInput!]
  OR: [SizeTypeWhereInput!]
  sm: Int
  sm_gt: Int
  sm_gte: Int
  sm_in: [Int!]
  sm_lt: Int
  sm_lte: Int
  sm_not: Int
  sm_not_in: [Int!]
  xl: Int
  xl_gt: Int
  xl_gte: Int
  xl_in: [Int!]
  xl_lt: Int
  xl_lte: Int
  xl_not: Int
  xl_not_in: [Int!]
  xs: Int
  xs_gt: Int
  xs_gte: Int
  xs_in: [Int!]
  xs_lt: Int
  xs_lte: Int
  xs_not: Int
  xs_not_in: [Int!]
}

input SizeTypeWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
}

type UserConnection {
  aggregate: AggregateUser!
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

input UserCreateInput {
  id: ID
  name: String!
}

type UserEdge {
  cursor: String!
  node: User!
}

enum UserOrderByInput {
  createdAt_ASC
  createdAt_DESC
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

input UserUpdateInput {
  name: String
}

input UserUpdateManyMutationInput {
  name: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  id: ID
  id_contains: ID
  id_ends_with: ID
  id_gt: ID
  id_gte: ID
  id_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_not: ID
  id_not_contains: ID
  id_not_ends_with: ID
  id_not_in: [ID!]
  id_not_starts_with: ID
  id_starts_with: ID
  name: String
  name_contains: String
  name_ends_with: String
  name_gt: String
  name_gte: String
  name_in: [String!]
  name_lt: String
  name_lte: String
  name_not: String
  name_not_contains: String
  name_not_ends_with: String
  name_not_in: [String!]
  name_not_starts_with: String
  name_starts_with: String
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
