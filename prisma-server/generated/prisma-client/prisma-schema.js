module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.32.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateBirth {
  count: Int!
}

type AggregateContact {
  count: Int!
}

type AggregateEmployee {
  count: Int!
}

type AggregateInsight {
  count: Int!
}

type AggregateMedia {
  count: Int!
}

type AggregateMetaType {
  count: Int!
}

type AggregateName {
  count: Int!
}

type AggregatePolicy {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateProfile {
  count: Int!
}

type AggregateSizeType {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Birth {
  id: ID!
  address: String
  city: String
  date: DateTime
  state: String
}

type BirthConnection {
  pageInfo: PageInfo!
  edges: [BirthEdge]!
  aggregate: AggregateBirth!
}

input BirthCreateInput {
  id: ID
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthCreateOneInput {
  create: BirthCreateInput
  connect: BirthWhereUniqueInput
}

type BirthEdge {
  node: Birth!
  cursor: String!
}

enum BirthOrderByInput {
  id_ASC
  id_DESC
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  date_ASC
  date_DESC
  state_ASC
  state_DESC
}

type BirthPreviousValues {
  id: ID!
  address: String
  city: String
  date: DateTime
  state: String
}

type BirthSubscriptionPayload {
  mutation: MutationType!
  node: Birth
  updatedFields: [String!]
  previousValues: BirthPreviousValues
}

input BirthSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BirthWhereInput
  AND: [BirthSubscriptionWhereInput!]
  OR: [BirthSubscriptionWhereInput!]
  NOT: [BirthSubscriptionWhereInput!]
}

input BirthUpdateDataInput {
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthUpdateInput {
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthUpdateManyMutationInput {
  address: String
  city: String
  date: DateTime
  state: String
}

input BirthUpdateOneInput {
  create: BirthCreateInput
  update: BirthUpdateDataInput
  upsert: BirthUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BirthWhereUniqueInput
}

input BirthUpsertNestedInput {
  update: BirthUpdateDataInput!
  create: BirthCreateInput!
}

input BirthWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [BirthWhereInput!]
  OR: [BirthWhereInput!]
  NOT: [BirthWhereInput!]
}

input BirthWhereUniqueInput {
  id: ID
}

type Contact {
  id: ID!
  address: String
  city: String
  phone: String
  state: String
}

type ContactConnection {
  pageInfo: PageInfo!
  edges: [ContactEdge]!
  aggregate: AggregateContact!
}

input ContactCreateInput {
  id: ID
  address: String
  city: String
  phone: String
  state: String
}

input ContactCreateOneInput {
  create: ContactCreateInput
  connect: ContactWhereUniqueInput
}

type ContactEdge {
  node: Contact!
  cursor: String!
}

enum ContactOrderByInput {
  id_ASC
  id_DESC
  address_ASC
  address_DESC
  city_ASC
  city_DESC
  phone_ASC
  phone_DESC
  state_ASC
  state_DESC
}

type ContactPreviousValues {
  id: ID!
  address: String
  city: String
  phone: String
  state: String
}

type ContactSubscriptionPayload {
  mutation: MutationType!
  node: Contact
  updatedFields: [String!]
  previousValues: ContactPreviousValues
}

input ContactSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContactWhereInput
  AND: [ContactSubscriptionWhereInput!]
  OR: [ContactSubscriptionWhereInput!]
  NOT: [ContactSubscriptionWhereInput!]
}

input ContactUpdateDataInput {
  address: String
  city: String
  phone: String
  state: String
}

input ContactUpdateInput {
  address: String
  city: String
  phone: String
  state: String
}

input ContactUpdateManyMutationInput {
  address: String
  city: String
  phone: String
  state: String
}

input ContactUpdateOneInput {
  create: ContactCreateInput
  update: ContactUpdateDataInput
  upsert: ContactUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ContactWhereUniqueInput
}

input ContactUpsertNestedInput {
  update: ContactUpdateDataInput!
  create: ContactCreateInput!
}

input ContactWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  AND: [ContactWhereInput!]
  OR: [ContactWhereInput!]
  NOT: [ContactWhereInput!]
}

input ContactWhereUniqueInput {
  id: ID
}

scalar DateTime

type Employee {
  id: ID!
  birth: Birth
  contact: Contact
  name: Name
  profile: Profile
}

type EmployeeConnection {
  pageInfo: PageInfo!
  edges: [EmployeeEdge]!
  aggregate: AggregateEmployee!
}

input EmployeeCreateInput {
  id: ID
  birth: BirthCreateOneInput
  contact: ContactCreateOneInput
  name: NameCreateOneInput
  profile: ProfileCreateOneInput
}

type EmployeeEdge {
  node: Employee!
  cursor: String!
}

enum EmployeeOrderByInput {
  id_ASC
  id_DESC
}

type EmployeePreviousValues {
  id: ID!
}

type EmployeeSubscriptionPayload {
  mutation: MutationType!
  node: Employee
  updatedFields: [String!]
  previousValues: EmployeePreviousValues
}

input EmployeeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EmployeeWhereInput
  AND: [EmployeeSubscriptionWhereInput!]
  OR: [EmployeeSubscriptionWhereInput!]
  NOT: [EmployeeSubscriptionWhereInput!]
}

input EmployeeUpdateInput {
  birth: BirthUpdateOneInput
  contact: ContactUpdateOneInput
  name: NameUpdateOneInput
  profile: ProfileUpdateOneInput
}

input EmployeeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  birth: BirthWhereInput
  contact: ContactWhereInput
  name: NameWhereInput
  profile: ProfileWhereInput
  AND: [EmployeeWhereInput!]
  OR: [EmployeeWhereInput!]
  NOT: [EmployeeWhereInput!]
}

input EmployeeWhereUniqueInput {
  id: ID
}

type Insight {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishedAt: DateTime
  authorId: String!
  category: String!
  content: String!
  desc: String!
  media: Media
  meta: MetaType
  title: String!
}

type InsightConnection {
  pageInfo: PageInfo!
  edges: [InsightEdge]!
  aggregate: AggregateInsight!
}

input InsightCreateInput {
  id: ID
  publishedAt: DateTime
  authorId: String!
  category: String!
  content: String!
  desc: String!
  media: MediaCreateOneInput
  meta: MetaTypeCreateOneInput
  title: String!
}

type InsightEdge {
  node: Insight!
  cursor: String!
}

enum InsightOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  publishedAt_ASC
  publishedAt_DESC
  authorId_ASC
  authorId_DESC
  category_ASC
  category_DESC
  content_ASC
  content_DESC
  desc_ASC
  desc_DESC
  title_ASC
  title_DESC
}

type InsightPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishedAt: DateTime
  authorId: String!
  category: String!
  content: String!
  desc: String!
  title: String!
}

type InsightSubscriptionPayload {
  mutation: MutationType!
  node: Insight
  updatedFields: [String!]
  previousValues: InsightPreviousValues
}

input InsightSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InsightWhereInput
  AND: [InsightSubscriptionWhereInput!]
  OR: [InsightSubscriptionWhereInput!]
  NOT: [InsightSubscriptionWhereInput!]
}

input InsightUpdateInput {
  publishedAt: DateTime
  authorId: String
  category: String
  content: String
  desc: String
  media: MediaUpdateOneInput
  meta: MetaTypeUpdateOneInput
  title: String
}

input InsightUpdateManyMutationInput {
  publishedAt: DateTime
  authorId: String
  category: String
  content: String
  desc: String
  title: String
}

input InsightWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  authorId: String
  authorId_not: String
  authorId_in: [String!]
  authorId_not_in: [String!]
  authorId_lt: String
  authorId_lte: String
  authorId_gt: String
  authorId_gte: String
  authorId_contains: String
  authorId_not_contains: String
  authorId_starts_with: String
  authorId_not_starts_with: String
  authorId_ends_with: String
  authorId_not_ends_with: String
  category: String
  category_not: String
  category_in: [String!]
  category_not_in: [String!]
  category_lt: String
  category_lte: String
  category_gt: String
  category_gte: String
  category_contains: String
  category_not_contains: String
  category_starts_with: String
  category_not_starts_with: String
  category_ends_with: String
  category_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  desc: String
  desc_not: String
  desc_in: [String!]
  desc_not_in: [String!]
  desc_lt: String
  desc_lte: String
  desc_gt: String
  desc_gte: String
  desc_contains: String
  desc_not_contains: String
  desc_starts_with: String
  desc_not_starts_with: String
  desc_ends_with: String
  desc_not_ends_with: String
  media: MediaWhereInput
  meta: MetaTypeWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [InsightWhereInput!]
  OR: [InsightWhereInput!]
  NOT: [InsightWhereInput!]
}

input InsightWhereUniqueInput {
  id: ID
}

scalar Long

type Media {
  id: ID!
  height: Int
  source: String!
  type: MediaType!
}

type MediaConnection {
  pageInfo: PageInfo!
  edges: [MediaEdge]!
  aggregate: AggregateMedia!
}

input MediaCreateInput {
  id: ID
  height: Int
  source: String!
  type: MediaType!
}

input MediaCreateOneInput {
  create: MediaCreateInput
  connect: MediaWhereUniqueInput
}

type MediaEdge {
  node: Media!
  cursor: String!
}

enum MediaOrderByInput {
  id_ASC
  id_DESC
  height_ASC
  height_DESC
  source_ASC
  source_DESC
  type_ASC
  type_DESC
}

type MediaPreviousValues {
  id: ID!
  height: Int
  source: String!
  type: MediaType!
}

type MediaSubscriptionPayload {
  mutation: MutationType!
  node: Media
  updatedFields: [String!]
  previousValues: MediaPreviousValues
}

input MediaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MediaWhereInput
  AND: [MediaSubscriptionWhereInput!]
  OR: [MediaSubscriptionWhereInput!]
  NOT: [MediaSubscriptionWhereInput!]
}

enum MediaType {
  Image
  Video
}

input MediaUpdateDataInput {
  height: Int
  source: String
  type: MediaType
}

input MediaUpdateInput {
  height: Int
  source: String
  type: MediaType
}

input MediaUpdateManyMutationInput {
  height: Int
  source: String
  type: MediaType
}

input MediaUpdateOneInput {
  create: MediaCreateInput
  update: MediaUpdateDataInput
  upsert: MediaUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MediaWhereUniqueInput
}

input MediaUpsertNestedInput {
  update: MediaUpdateDataInput!
  create: MediaCreateInput!
}

input MediaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  type: MediaType
  type_not: MediaType
  type_in: [MediaType!]
  type_not_in: [MediaType!]
  AND: [MediaWhereInput!]
  OR: [MediaWhereInput!]
  NOT: [MediaWhereInput!]
}

input MediaWhereUniqueInput {
  id: ID
}

type MetaType {
  id: ID!
  featured: Boolean
  size: SizeType
}

type MetaTypeConnection {
  pageInfo: PageInfo!
  edges: [MetaTypeEdge]!
  aggregate: AggregateMetaType!
}

input MetaTypeCreateInput {
  id: ID
  featured: Boolean
  size: SizeTypeCreateOneInput
}

input MetaTypeCreateOneInput {
  create: MetaTypeCreateInput
  connect: MetaTypeWhereUniqueInput
}

type MetaTypeEdge {
  node: MetaType!
  cursor: String!
}

enum MetaTypeOrderByInput {
  id_ASC
  id_DESC
  featured_ASC
  featured_DESC
}

type MetaTypePreviousValues {
  id: ID!
  featured: Boolean
}

type MetaTypeSubscriptionPayload {
  mutation: MutationType!
  node: MetaType
  updatedFields: [String!]
  previousValues: MetaTypePreviousValues
}

input MetaTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MetaTypeWhereInput
  AND: [MetaTypeSubscriptionWhereInput!]
  OR: [MetaTypeSubscriptionWhereInput!]
  NOT: [MetaTypeSubscriptionWhereInput!]
}

input MetaTypeUpdateDataInput {
  featured: Boolean
  size: SizeTypeUpdateOneInput
}

input MetaTypeUpdateInput {
  featured: Boolean
  size: SizeTypeUpdateOneInput
}

input MetaTypeUpdateManyMutationInput {
  featured: Boolean
}

input MetaTypeUpdateOneInput {
  create: MetaTypeCreateInput
  update: MetaTypeUpdateDataInput
  upsert: MetaTypeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MetaTypeWhereUniqueInput
}

input MetaTypeUpsertNestedInput {
  update: MetaTypeUpdateDataInput!
  create: MetaTypeCreateInput!
}

input MetaTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  featured: Boolean
  featured_not: Boolean
  size: SizeTypeWhereInput
  AND: [MetaTypeWhereInput!]
  OR: [MetaTypeWhereInput!]
  NOT: [MetaTypeWhereInput!]
}

input MetaTypeWhereUniqueInput {
  id: ID
}

type Mutation {
  createBirth(data: BirthCreateInput!): Birth!
  updateBirth(data: BirthUpdateInput!, where: BirthWhereUniqueInput!): Birth
  updateManyBirths(data: BirthUpdateManyMutationInput!, where: BirthWhereInput): BatchPayload!
  upsertBirth(where: BirthWhereUniqueInput!, create: BirthCreateInput!, update: BirthUpdateInput!): Birth!
  deleteBirth(where: BirthWhereUniqueInput!): Birth
  deleteManyBirths(where: BirthWhereInput): BatchPayload!
  createContact(data: ContactCreateInput!): Contact!
  updateContact(data: ContactUpdateInput!, where: ContactWhereUniqueInput!): Contact
  updateManyContacts(data: ContactUpdateManyMutationInput!, where: ContactWhereInput): BatchPayload!
  upsertContact(where: ContactWhereUniqueInput!, create: ContactCreateInput!, update: ContactUpdateInput!): Contact!
  deleteContact(where: ContactWhereUniqueInput!): Contact
  deleteManyContacts(where: ContactWhereInput): BatchPayload!
  createEmployee(data: EmployeeCreateInput!): Employee!
  updateEmployee(data: EmployeeUpdateInput!, where: EmployeeWhereUniqueInput!): Employee
  upsertEmployee(where: EmployeeWhereUniqueInput!, create: EmployeeCreateInput!, update: EmployeeUpdateInput!): Employee!
  deleteEmployee(where: EmployeeWhereUniqueInput!): Employee
  deleteManyEmployees(where: EmployeeWhereInput): BatchPayload!
  createInsight(data: InsightCreateInput!): Insight!
  updateInsight(data: InsightUpdateInput!, where: InsightWhereUniqueInput!): Insight
  updateManyInsights(data: InsightUpdateManyMutationInput!, where: InsightWhereInput): BatchPayload!
  upsertInsight(where: InsightWhereUniqueInput!, create: InsightCreateInput!, update: InsightUpdateInput!): Insight!
  deleteInsight(where: InsightWhereUniqueInput!): Insight
  deleteManyInsights(where: InsightWhereInput): BatchPayload!
  createMedia(data: MediaCreateInput!): Media!
  updateMedia(data: MediaUpdateInput!, where: MediaWhereUniqueInput!): Media
  updateManyMedias(data: MediaUpdateManyMutationInput!, where: MediaWhereInput): BatchPayload!
  upsertMedia(where: MediaWhereUniqueInput!, create: MediaCreateInput!, update: MediaUpdateInput!): Media!
  deleteMedia(where: MediaWhereUniqueInput!): Media
  deleteManyMedias(where: MediaWhereInput): BatchPayload!
  createMetaType(data: MetaTypeCreateInput!): MetaType!
  updateMetaType(data: MetaTypeUpdateInput!, where: MetaTypeWhereUniqueInput!): MetaType
  updateManyMetaTypes(data: MetaTypeUpdateManyMutationInput!, where: MetaTypeWhereInput): BatchPayload!
  upsertMetaType(where: MetaTypeWhereUniqueInput!, create: MetaTypeCreateInput!, update: MetaTypeUpdateInput!): MetaType!
  deleteMetaType(where: MetaTypeWhereUniqueInput!): MetaType
  deleteManyMetaTypes(where: MetaTypeWhereInput): BatchPayload!
  createName(data: NameCreateInput!): Name!
  updateName(data: NameUpdateInput!, where: NameWhereUniqueInput!): Name
  updateManyNames(data: NameUpdateManyMutationInput!, where: NameWhereInput): BatchPayload!
  upsertName(where: NameWhereUniqueInput!, create: NameCreateInput!, update: NameUpdateInput!): Name!
  deleteName(where: NameWhereUniqueInput!): Name
  deleteManyNames(where: NameWhereInput): BatchPayload!
  createPolicy(data: PolicyCreateInput!): Policy!
  updatePolicy(data: PolicyUpdateInput!, where: PolicyWhereUniqueInput!): Policy
  updateManyPolicies(data: PolicyUpdateManyMutationInput!, where: PolicyWhereInput): BatchPayload!
  upsertPolicy(where: PolicyWhereUniqueInput!, create: PolicyCreateInput!, update: PolicyUpdateInput!): Policy!
  deletePolicy(where: PolicyWhereUniqueInput!): Policy
  deleteManyPolicies(where: PolicyWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createProfile(data: ProfileCreateInput!): Profile!
  updateProfile(data: ProfileUpdateInput!, where: ProfileWhereUniqueInput!): Profile
  updateManyProfiles(data: ProfileUpdateManyMutationInput!, where: ProfileWhereInput): BatchPayload!
  upsertProfile(where: ProfileWhereUniqueInput!, create: ProfileCreateInput!, update: ProfileUpdateInput!): Profile!
  deleteProfile(where: ProfileWhereUniqueInput!): Profile
  deleteManyProfiles(where: ProfileWhereInput): BatchPayload!
  createSizeType(data: SizeTypeCreateInput!): SizeType!
  updateSizeType(data: SizeTypeUpdateInput!, where: SizeTypeWhereUniqueInput!): SizeType
  updateManySizeTypes(data: SizeTypeUpdateManyMutationInput!, where: SizeTypeWhereInput): BatchPayload!
  upsertSizeType(where: SizeTypeWhereUniqueInput!, create: SizeTypeCreateInput!, update: SizeTypeUpdateInput!): SizeType!
  deleteSizeType(where: SizeTypeWhereUniqueInput!): SizeType
  deleteManySizeTypes(where: SizeTypeWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Name {
  id: ID!
  first: String!
  middle: String
  last: String!
  preferred: String
}

type NameConnection {
  pageInfo: PageInfo!
  edges: [NameEdge]!
  aggregate: AggregateName!
}

input NameCreateInput {
  id: ID
  first: String!
  middle: String
  last: String!
  preferred: String
}

input NameCreateOneInput {
  create: NameCreateInput
  connect: NameWhereUniqueInput
}

type NameEdge {
  node: Name!
  cursor: String!
}

enum NameOrderByInput {
  id_ASC
  id_DESC
  first_ASC
  first_DESC
  middle_ASC
  middle_DESC
  last_ASC
  last_DESC
  preferred_ASC
  preferred_DESC
}

type NamePreviousValues {
  id: ID!
  first: String!
  middle: String
  last: String!
  preferred: String
}

type NameSubscriptionPayload {
  mutation: MutationType!
  node: Name
  updatedFields: [String!]
  previousValues: NamePreviousValues
}

input NameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NameWhereInput
  AND: [NameSubscriptionWhereInput!]
  OR: [NameSubscriptionWhereInput!]
  NOT: [NameSubscriptionWhereInput!]
}

input NameUpdateDataInput {
  first: String
  middle: String
  last: String
  preferred: String
}

input NameUpdateInput {
  first: String
  middle: String
  last: String
  preferred: String
}

input NameUpdateManyMutationInput {
  first: String
  middle: String
  last: String
  preferred: String
}

input NameUpdateOneInput {
  create: NameCreateInput
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: NameWhereUniqueInput
}

input NameUpsertNestedInput {
  update: NameUpdateDataInput!
  create: NameCreateInput!
}

input NameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  first: String
  first_not: String
  first_in: [String!]
  first_not_in: [String!]
  first_lt: String
  first_lte: String
  first_gt: String
  first_gte: String
  first_contains: String
  first_not_contains: String
  first_starts_with: String
  first_not_starts_with: String
  first_ends_with: String
  first_not_ends_with: String
  middle: String
  middle_not: String
  middle_in: [String!]
  middle_not_in: [String!]
  middle_lt: String
  middle_lte: String
  middle_gt: String
  middle_gte: String
  middle_contains: String
  middle_not_contains: String
  middle_starts_with: String
  middle_not_starts_with: String
  middle_ends_with: String
  middle_not_ends_with: String
  last: String
  last_not: String
  last_in: [String!]
  last_not_in: [String!]
  last_lt: String
  last_lte: String
  last_gt: String
  last_gte: String
  last_contains: String
  last_not_contains: String
  last_starts_with: String
  last_not_starts_with: String
  last_ends_with: String
  last_not_ends_with: String
  preferred: String
  preferred_not: String
  preferred_in: [String!]
  preferred_not_in: [String!]
  preferred_lt: String
  preferred_lte: String
  preferred_gt: String
  preferred_gte: String
  preferred_contains: String
  preferred_not_contains: String
  preferred_starts_with: String
  preferred_not_starts_with: String
  preferred_ends_with: String
  preferred_not_ends_with: String
  AND: [NameWhereInput!]
  OR: [NameWhereInput!]
  NOT: [NameWhereInput!]
}

input NameWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Policy {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  publishedAt: DateTime
  content: String!
  title: String!
}

type PolicyConnection {
  pageInfo: PageInfo!
  edges: [PolicyEdge]!
  aggregate: AggregatePolicy!
}

input PolicyCreateInput {
  id: ID
  publishedAt: DateTime
  content: String!
  title: String!
}

type PolicyEdge {
  node: Policy!
  cursor: String!
}

enum PolicyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  publishedAt_ASC
  publishedAt_DESC
  content_ASC
  content_DESC
  title_ASC
  title_DESC
}

type PolicyPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime
  publishedAt: DateTime
  content: String!
  title: String!
}

type PolicySubscriptionPayload {
  mutation: MutationType!
  node: Policy
  updatedFields: [String!]
  previousValues: PolicyPreviousValues
}

input PolicySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PolicyWhereInput
  AND: [PolicySubscriptionWhereInput!]
  OR: [PolicySubscriptionWhereInput!]
  NOT: [PolicySubscriptionWhereInput!]
}

input PolicyUpdateInput {
  publishedAt: DateTime
  content: String
  title: String
}

input PolicyUpdateManyMutationInput {
  publishedAt: DateTime
  content: String
  title: String
}

input PolicyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  publishedAt: DateTime
  publishedAt_not: DateTime
  publishedAt_in: [DateTime!]
  publishedAt_not_in: [DateTime!]
  publishedAt_lt: DateTime
  publishedAt_lte: DateTime
  publishedAt_gt: DateTime
  publishedAt_gte: DateTime
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [PolicyWhereInput!]
  OR: [PolicyWhereInput!]
  NOT: [PolicyWhereInput!]
}

input PolicyWhereUniqueInput {
  id: ID
}

type Post {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  imageUrl: String!
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  description: String!
  imageUrl: String!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  description_ASC
  description_DESC
  imageUrl_ASC
  imageUrl_DESC
}

type PostPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  description: String!
  imageUrl: String!
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  description: String
  imageUrl: String
}

input PostUpdateManyMutationInput {
  description: String
  imageUrl: String
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  imageUrl: String
  imageUrl_not: String
  imageUrl_in: [String!]
  imageUrl_not_in: [String!]
  imageUrl_lt: String
  imageUrl_lte: String
  imageUrl_gt: String
  imageUrl_gte: String
  imageUrl_contains: String
  imageUrl_not_contains: String
  imageUrl_starts_with: String
  imageUrl_not_starts_with: String
  imageUrl_ends_with: String
  imageUrl_not_ends_with: String
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Profile {
  id: ID!
  bio: String!
  level: Int
  media: Media
  title: String!
}

type ProfileConnection {
  pageInfo: PageInfo!
  edges: [ProfileEdge]!
  aggregate: AggregateProfile!
}

input ProfileCreateInput {
  id: ID
  bio: String!
  level: Int
  media: MediaCreateOneInput
  title: String!
}

input ProfileCreateOneInput {
  create: ProfileCreateInput
  connect: ProfileWhereUniqueInput
}

type ProfileEdge {
  node: Profile!
  cursor: String!
}

enum ProfileOrderByInput {
  id_ASC
  id_DESC
  bio_ASC
  bio_DESC
  level_ASC
  level_DESC
  title_ASC
  title_DESC
}

type ProfilePreviousValues {
  id: ID!
  bio: String!
  level: Int
  title: String!
}

type ProfileSubscriptionPayload {
  mutation: MutationType!
  node: Profile
  updatedFields: [String!]
  previousValues: ProfilePreviousValues
}

input ProfileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProfileWhereInput
  AND: [ProfileSubscriptionWhereInput!]
  OR: [ProfileSubscriptionWhereInput!]
  NOT: [ProfileSubscriptionWhereInput!]
}

input ProfileUpdateDataInput {
  bio: String
  level: Int
  media: MediaUpdateOneInput
  title: String
}

input ProfileUpdateInput {
  bio: String
  level: Int
  media: MediaUpdateOneInput
  title: String
}

input ProfileUpdateManyMutationInput {
  bio: String
  level: Int
  title: String
}

input ProfileUpdateOneInput {
  create: ProfileCreateInput
  update: ProfileUpdateDataInput
  upsert: ProfileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProfileWhereUniqueInput
}

input ProfileUpsertNestedInput {
  update: ProfileUpdateDataInput!
  create: ProfileCreateInput!
}

input ProfileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  level: Int
  level_not: Int
  level_in: [Int!]
  level_not_in: [Int!]
  level_lt: Int
  level_lte: Int
  level_gt: Int
  level_gte: Int
  media: MediaWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
}

input ProfileWhereUniqueInput {
  id: ID
}

type Query {
  birth(where: BirthWhereUniqueInput!): Birth
  births(where: BirthWhereInput, orderBy: BirthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Birth]!
  birthsConnection(where: BirthWhereInput, orderBy: BirthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BirthConnection!
  contact(where: ContactWhereUniqueInput!): Contact
  contacts(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contact]!
  contactsConnection(where: ContactWhereInput, orderBy: ContactOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactConnection!
  employee(where: EmployeeWhereUniqueInput!): Employee
  employees(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Employee]!
  employeesConnection(where: EmployeeWhereInput, orderBy: EmployeeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EmployeeConnection!
  insight(where: InsightWhereUniqueInput!): Insight
  insights(where: InsightWhereInput, orderBy: InsightOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Insight]!
  insightsConnection(where: InsightWhereInput, orderBy: InsightOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InsightConnection!
  media(where: MediaWhereUniqueInput!): Media
  medias(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Media]!
  mediasConnection(where: MediaWhereInput, orderBy: MediaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MediaConnection!
  metaType(where: MetaTypeWhereUniqueInput!): MetaType
  metaTypes(where: MetaTypeWhereInput, orderBy: MetaTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MetaType]!
  metaTypesConnection(where: MetaTypeWhereInput, orderBy: MetaTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MetaTypeConnection!
  name(where: NameWhereUniqueInput!): Name
  names(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Name]!
  namesConnection(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NameConnection!
  policy(where: PolicyWhereUniqueInput!): Policy
  policies(where: PolicyWhereInput, orderBy: PolicyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Policy]!
  policiesConnection(where: PolicyWhereInput, orderBy: PolicyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PolicyConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  profile(where: ProfileWhereUniqueInput!): Profile
  profiles(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Profile]!
  profilesConnection(where: ProfileWhereInput, orderBy: ProfileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProfileConnection!
  sizeType(where: SizeTypeWhereUniqueInput!): SizeType
  sizeTypes(where: SizeTypeWhereInput, orderBy: SizeTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SizeType]!
  sizeTypesConnection(where: SizeTypeWhereInput, orderBy: SizeTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SizeTypeConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type SizeType {
  id: ID!
  xs: Int
  sm: Int
  md: Int
  lg: Int
  xl: Int
}

type SizeTypeConnection {
  pageInfo: PageInfo!
  edges: [SizeTypeEdge]!
  aggregate: AggregateSizeType!
}

input SizeTypeCreateInput {
  id: ID
  xs: Int
  sm: Int
  md: Int
  lg: Int
  xl: Int
}

input SizeTypeCreateOneInput {
  create: SizeTypeCreateInput
  connect: SizeTypeWhereUniqueInput
}

type SizeTypeEdge {
  node: SizeType!
  cursor: String!
}

enum SizeTypeOrderByInput {
  id_ASC
  id_DESC
  xs_ASC
  xs_DESC
  sm_ASC
  sm_DESC
  md_ASC
  md_DESC
  lg_ASC
  lg_DESC
  xl_ASC
  xl_DESC
}

type SizeTypePreviousValues {
  id: ID!
  xs: Int
  sm: Int
  md: Int
  lg: Int
  xl: Int
}

type SizeTypeSubscriptionPayload {
  mutation: MutationType!
  node: SizeType
  updatedFields: [String!]
  previousValues: SizeTypePreviousValues
}

input SizeTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SizeTypeWhereInput
  AND: [SizeTypeSubscriptionWhereInput!]
  OR: [SizeTypeSubscriptionWhereInput!]
  NOT: [SizeTypeSubscriptionWhereInput!]
}

input SizeTypeUpdateDataInput {
  xs: Int
  sm: Int
  md: Int
  lg: Int
  xl: Int
}

input SizeTypeUpdateInput {
  xs: Int
  sm: Int
  md: Int
  lg: Int
  xl: Int
}

input SizeTypeUpdateManyMutationInput {
  xs: Int
  sm: Int
  md: Int
  lg: Int
  xl: Int
}

input SizeTypeUpdateOneInput {
  create: SizeTypeCreateInput
  update: SizeTypeUpdateDataInput
  upsert: SizeTypeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SizeTypeWhereUniqueInput
}

input SizeTypeUpsertNestedInput {
  update: SizeTypeUpdateDataInput!
  create: SizeTypeCreateInput!
}

input SizeTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  xs: Int
  xs_not: Int
  xs_in: [Int!]
  xs_not_in: [Int!]
  xs_lt: Int
  xs_lte: Int
  xs_gt: Int
  xs_gte: Int
  sm: Int
  sm_not: Int
  sm_in: [Int!]
  sm_not_in: [Int!]
  sm_lt: Int
  sm_lte: Int
  sm_gt: Int
  sm_gte: Int
  md: Int
  md_not: Int
  md_in: [Int!]
  md_not_in: [Int!]
  md_lt: Int
  md_lte: Int
  md_gt: Int
  md_gte: Int
  lg: Int
  lg_not: Int
  lg_in: [Int!]
  lg_not_in: [Int!]
  lg_lt: Int
  lg_lte: Int
  lg_gt: Int
  lg_gte: Int
  xl: Int
  xl_not: Int
  xl_in: [Int!]
  xl_not_in: [Int!]
  xl_lt: Int
  xl_lte: Int
  xl_gt: Int
  xl_gte: Int
  AND: [SizeTypeWhereInput!]
  OR: [SizeTypeWhereInput!]
  NOT: [SizeTypeWhereInput!]
}

input SizeTypeWhereUniqueInput {
  id: ID
}

type Subscription {
  birth(where: BirthSubscriptionWhereInput): BirthSubscriptionPayload
  contact(where: ContactSubscriptionWhereInput): ContactSubscriptionPayload
  employee(where: EmployeeSubscriptionWhereInput): EmployeeSubscriptionPayload
  insight(where: InsightSubscriptionWhereInput): InsightSubscriptionPayload
  media(where: MediaSubscriptionWhereInput): MediaSubscriptionPayload
  metaType(where: MetaTypeSubscriptionWhereInput): MetaTypeSubscriptionPayload
  name(where: NameSubscriptionWhereInput): NameSubscriptionPayload
  policy(where: PolicySubscriptionWhereInput): PolicySubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  profile(where: ProfileSubscriptionWhereInput): ProfileSubscriptionPayload
  sizeType(where: SizeTypeSubscriptionWhereInput): SizeTypeSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
}

input UserUpdateManyMutationInput {
  name: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`
      }
    